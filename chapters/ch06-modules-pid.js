window.CHAPTERS = window.CHAPTERS || [];
window.CHAPTERS.push({
    id: 'ch06',
    number: 6,
    title: 'Modules over a Principal Ideal Domain',
    subtitle: 'Structure theorems, invariant factors, and elementary divisors',
    sections: [
        {
            id: 'ch06-sec01',
            title: 'Free Modules over PIDs',
            content: `
                <h2>Free Modules over PIDs</h2>

                <p>In this chapter, we study finitely generated modules over a principal ideal domain (PID). The structure theorem for such modules is one of the most powerful results in algebra, with applications ranging from canonical forms for matrices to the classification of finitely generated abelian groups.</p>

                <div class="env-block definition">
                    <div class="env-title">Definition 6.1 (Principal Ideal Domain)</div>
                    <div class="env-body">
                        <p>A <strong>principal ideal domain</strong> (PID) is an integral domain \\(R\\) in which every ideal is principal, i.e., of the form \\(\\langle a \\rangle = \\{ra : r \\in R\\}\\) for some \\(a \\in R\\).</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.2 (Examples of PIDs)</div>
                    <div class="env-body">
                        <p><strong>1. The integers \\(\\mathbb{Z}\\):</strong> Every ideal in \\(\\mathbb{Z}\\) is of the form \\(n\\mathbb{Z}\\) for some \\(n \\geq 0\\).</p>
                        <p><strong>2. Polynomial rings \\(F[x]\\) over a field:</strong> If \\(F\\) is a field, then \\(F[x]\\) is a PID. Every ideal is generated by a single polynomial.</p>
                        <p><strong>3. Gaussian integers \\(\\mathbb{Z}[i]\\):</strong> The ring \\(\\{a + bi : a,b \\in \\mathbb{Z}\\}\\) is a PID.</p>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 6.3 (Free Module)</div>
                    <div class="env-body">
                        <p>An \\(R\\)-module \\(M\\) is <strong>free</strong> if it has a basis, i.e., a linearly independent generating set \\(B = \\{e_1, \\ldots, e_n\\}\\) such that every element \\(m \\in M\\) can be uniquely written as</p>
                        \\[m = r_1 e_1 + \\cdots + r_n e_n\\]
                        <p>for some \\(r_1, \\ldots, r_n \\in R\\). The cardinality of \\(B\\) is called the <strong>rank</strong> of \\(M\\), denoted \\(\\operatorname{rk}(M)\\).</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.4 (Submodules of Free Modules over PIDs)</div>
                    <div class="env-body">
                        <p>Let \\(R\\) be a principal ideal domain and let \\(M\\) be a free \\(R\\)-module of rank \\(n\\). Then every submodule \\(N\\) of \\(M\\) is free of rank at most \\(n\\).</p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof (Sketch)</div>
                    <div class="env-body">
                        <p>We proceed by induction on \\(n = \\operatorname{rk}(M)\\). For \\(n = 1\\), we have \\(M \\cong R\\), and every submodule is an ideal, hence principal and thus free of rank 0 or 1.</p>
                        <p>For the inductive step, assume \\(M\\) has basis \\(\\{e_1, \\ldots, e_n\\}\\). Consider the projection \\(\\pi: M \\to R e_n\\) and the submodule \\(N' = N \\cap \\ker(\\pi)\\). Since \\(\\ker(\\pi)\\) is free of rank \\(n-1\\), by induction \\(N'\\) is free. The image \\(\\pi(N)\\) is an ideal in \\(R\\), hence free of rank at most 1. Using these facts, we can construct a basis for \\(N\\).</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="env-block intuition">
                    <div class="env-title">Intuition</div>
                    <div class="env-body">
                        <p>This theorem is remarkable because it fails for modules over general rings. For example, the \\(\\mathbb{Z}\\)-module \\(\\mathbb{Z}/2\\mathbb{Z}\\) is not free (it has torsion), yet it is a quotient (hence related to a submodule) of the free module \\(\\mathbb{Z}\\).</p>
                        <p>The key is that PIDs have a division algorithm-like structure that allows us to "simplify" module elements systematically.</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.5 (Rank is Well-Defined)</div>
                    <div class="env-body">
                        <p>If \\(M\\) is a free module over a PID \\(R\\), then all bases of \\(M\\) have the same cardinality. Thus the rank is well-defined.</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.6 (Torsion-Free and Free)</div>
                    <div class="env-body">
                        <p>A finitely generated module over a PID is free if and only if it is torsion-free.</p>
                        <p>Recall: An element \\(m \\in M\\) is <strong>torsion</strong> if \\(rm = 0\\) for some nonzero \\(r \\in R\\). The module \\(M\\) is <strong>torsion-free</strong> if its only torsion element is 0.</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="free-module-viz"></div>
            `,
            visualizations: [
                {
                    id: 'free-module-viz',
                    title: 'Interactive: Free Module Structure',
                    description: 'Visualize ℤ² as a free ℤ-module with basis vectors. Drag to create linear combinations.',
                    setup: function(container, controls) {
                        const viz = new VizEngine(container, {width: 600, height: 450, scale: 30});

                        const e1 = viz.addDraggable('e1', 1, 0, viz.colors.blue, 8, () => draw());
                        const e2 = viz.addDraggable('e2', 0, 1, viz.colors.orange, 8, () => draw());

                        let showLattice = true;
                        VizEngine.createButton(controls, 'Toggle Lattice', () => {
                            showLattice = !showLattice;
                            draw();
                        });

                        function draw() {
                            viz.clear();
                            viz.drawGrid();
                            viz.drawAxes();

                            // Draw integer linear combinations (lattice points)
                            if (showLattice) {
                                for (let a = -8; a <= 8; a++) {
                                    for (let b = -8; b <= 8; b++) {
                                        const x = a * e1.x + b * e2.x;
                                        const y = a * e1.y + b * e2.y;
                                        viz.drawPoint(x, y, viz.colors.teal + '66', null, 3);
                                    }
                                }
                            }

                            // Highlight some linear combinations
                            const combo1 = {x: 2*e1.x + 3*e2.x, y: 2*e1.y + 3*e2.y};
                            const combo2 = {x: -1*e1.x + 2*e2.x, y: -1*e1.y + 2*e2.y};

                            viz.drawPoint(combo1.x, combo1.y, viz.colors.green, '2e₁+3e₂', 6);
                            viz.drawPoint(combo2.x, combo2.y, viz.colors.purple, '-e₁+2e₂', 6);

                            viz.drawVector(0, 0, e1.x, e1.y, viz.colors.blue, 'e₁', 3);
                            viz.drawVector(0, 0, e2.x, e2.y, viz.colors.orange, 'e₂', 3);
                            viz.drawDraggables();

                            viz.drawText('Free ℤ-module of rank 2', -9, 7, viz.colors.text, 14);
                        }

                        draw();
                        return viz;
                    }
                }
            ],
            exercises: [
                {
                    question: 'Prove that any free module over an integral domain is torsion-free.',
                    hint: 'Suppose \\(rm = 0\\) for \\(m = \\sum r_i e_i\\) nonzero and \\(r \\neq 0\\). Use the fact that \\(R\\) is an integral domain.',
                    solution: 'Let \\(M\\) be free with basis \\(\\{e_1, \\ldots, e_n\\}\\) and suppose \\(rm = 0\\) for some \\(r \\neq 0\\) and \\(m = r_1 e_1 + \\cdots + r_n e_n \\neq 0\\). Then \\(rr_1 e_1 + \\cdots + rr_n e_n = 0\\). By linear independence, \\(rr_i = 0\\) for all \\(i\\). Since \\(r \\neq 0\\) and \\(R\\) is an integral domain, \\(r_i = 0\\) for all \\(i\\), so \\(m = 0\\), a contradiction.'
                },
                {
                    question: 'Show that \\(\\mathbb{Q}\\) is a torsion-free \\(\\mathbb{Z}\\)-module that is not free.',
                    hint: 'To show it is not free, suppose \\(\\{q_1, \\ldots, q_n\\}\\) is a basis and derive a contradiction by considering \\(\\frac{1}{2}q_1\\).',
                    solution: '\\(\\mathbb{Q}\\) is torsion-free: if \\(nq = 0\\) for \\(n \\in \\mathbb{Z} \\setminus \\{0\\}\\) and \\(q \\in \\mathbb{Q}\\), then \\(q = 0\\). It is not free: suppose \\(B = \\{q_1, \\ldots, q_n\\}\\) is a basis. Then \\(\\frac{1}{2}q_1\\) can be written uniquely as \\(\\frac{1}{2}q_1 = m_1 q_1 + \\cdots + m_n q_n\\) for some \\(m_i \\in \\mathbb{Z}\\). This gives \\((\\frac{1}{2} - m_1)q_1 - m_2 q_2 - \\cdots - m_n q_n = 0\\), so \\(\\frac{1}{2} = m_1 \\in \\mathbb{Z}\\), a contradiction.'
                },
                {
                    question: 'Let \\(M = \\mathbb{Z} \\times \\mathbb{Z}\\) as a \\(\\mathbb{Z}\\)-module. Show that \\(N = \\{(2m, 3n) : m,n \\in \\mathbb{Z}\\}\\) is a submodule and find a basis for \\(N\\).',
                    hint: 'Check that \\(N\\) is closed under addition and scalar multiplication. For a basis, consider \\((2,0)\\) and \\((0,3)\\).',
                    solution: '\\(N\\) is a submodule: it contains \\((0,0)\\), is closed under addition since \\((2m_1,3n_1)+(2m_2,3n_2) = (2(m_1+m_2), 3(n_1+n_2)) \\in N\\), and closed under scalar multiplication since \\(k(2m,3n) = (2km, 3kn) \\in N\\). A basis for \\(N\\) is \\(\\{(2,0), (0,3)\\}\\) since any \\((2m,3n) = m(2,0) + n(0,3)\\) and this representation is unique.'
                }
            ]
        },
        {
            id: 'ch06-sec02',
            title: 'Torsion Modules and Primary Decomposition',
            content: `
                <h2>Torsion Modules and Primary Decomposition</h2>

                <div class="env-block definition">
                    <div class="env-title">Definition 6.7 (Torsion Module)</div>
                    <div class="env-body">
                        <p>An \\(R\\)-module \\(M\\) is a <strong>torsion module</strong> if every element is torsion, i.e., for every \\(m \\in M\\), there exists nonzero \\(r \\in R\\) such that \\(rm = 0\\).</p>
                        <p>The <strong>annihilator</strong> of \\(M\\) is</p>
                        \\[\\operatorname{ann}(M) = \\{r \\in R : rm = 0 \\text{ for all } m \\in M\\}\\]
                        <p>The <strong>order</strong> of \\(M\\) is any generator of \\(\\operatorname{ann}(M)\\) (when \\(R\\) is a PID).</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.8 (Free-Torsion Decomposition)</div>
                    <div class="env-body">
                        <p>Any finitely generated module \\(M\\) over a PID \\(R\\) decomposes uniquely as</p>
                        \\[M = M_{\\text{free}} \\oplus M_{\\text{tor}}\\]
                        <p>where \\(M_{\\text{free}}\\) is free and \\(M_{\\text{tor}}\\) is the torsion submodule (all torsion elements).</p>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 6.9 (Primary Module)</div>
                    <div class="env-body">
                        <p>Let \\(p \\in R\\) be prime. A module \\(M\\) is <strong>\\(p\\)-primary</strong> if its order is a power of \\(p\\), i.e., \\(\\operatorname{ann}(M) = \\langle p^k \\rangle\\) for some \\(k \\geq 1\\).</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.10 (Primary Decomposition)</div>
                    <div class="env-body">
                        <p>Let \\(M\\) be a torsion module over a PID \\(R\\) with order</p>
                        \\[\\tau = p_1^{e_1} \\cdots p_k^{e_k}\\]
                        <p>where \\(p_i\\) are distinct primes. Then</p>
                        \\[M = M_{p_1} \\oplus \\cdots \\oplus M_{p_k}\\]
                        <p>where \\(M_{p_i} = \\{m \\in M : p_i^{e_i} m = 0\\}\\) is the \\(p_i\\)-primary component. This decomposition is unique up to order.</p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof (Sketch)</div>
                    <div class="env-body">
                        <p><strong>Existence:</strong> Since \\(\\gcd(p_1^{e_1}, \\ldots, p_k^{e_k}) = 1\\), there exist \\(r_1, \\ldots, r_k \\in R\\) with</p>
                        \\[r_1 \\tau_1 + \\cdots + r_k \\tau_k = 1\\]
                        <p>where \\(\\tau_i = \\tau / p_i^{e_i}\\). For any \\(m \\in M\\), we have</p>
                        \\[m = r_1\\tau_1 m + \\cdots + r_k\\tau_k m\\]
                        <p>Each \\(r_i\\tau_i m \\in M_{p_i}\\) since \\(p_i^{e_i}(r_i\\tau_i m) = r_i \\tau m = 0\\).</p>
                        <p><strong>Uniqueness:</strong> Follows from the fact that the annihilators are pairwise coprime.</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.11 (Primary Decomposition of \\(\\mathbb{Z}/12\\mathbb{Z}\\))</div>
                    <div class="env-body">
                        <p>Consider the \\(\\mathbb{Z}\\)-module \\(M = \\mathbb{Z}/12\\mathbb{Z}\\). Since \\(12 = 2^2 \\cdot 3\\), we have</p>
                        \\[\\mathbb{Z}/12\\mathbb{Z} \\cong \\mathbb{Z}/4\\mathbb{Z} \\oplus \\mathbb{Z}/3\\mathbb{Z}\\]
                        <p>The isomorphism is given by \\(n \\bmod 12 \\mapsto (n \\bmod 4, n \\bmod 3)\\), which is the Chinese Remainder Theorem.</p>
                        <p>Here, \\(M_2 = \\mathbb{Z}/4\\mathbb{Z}\\) is 2-primary and \\(M_3 = \\mathbb{Z}/3\\mathbb{Z}\\) is 3-primary.</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="primary-decomp-viz"></div>

                <div class="env-block remark">
                    <div class="env-title">Remark</div>
                    <div class="env-body">
                        <p>The primary decomposition is the algebraic analog of the Fundamental Theorem of Arithmetic. It says that every torsion module can be uniquely "factored" into primary components, just as every integer factors uniquely into prime powers.</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'primary-decomp-viz',
                    title: 'Interactive: Primary Decomposition of ℤ/nℤ',
                    description: 'Explore the primary decomposition of cyclic groups',
                    setup: function(container, controls) {
                        const viz = new VizEngine(container, {width: 700, height: 400, scale: 1});

                        let n = 12;
                        const slider = VizEngine.createSlider(controls, 'n = ' + n, 2, 60, 12, 1, (val) => {
                            n = val;
                            slider.previousElementSibling.textContent = 'n = ' + n;
                            draw();
                        });

                        function primeFactorization(num) {
                            const factors = [];
                            let d = 2;
                            while (d * d <= num) {
                                let exp = 0;
                                while (num % d === 0) {
                                    exp++;
                                    num /= d;
                                }
                                if (exp > 0) factors.push({p: d, e: exp});
                                d++;
                            }
                            if (num > 1) factors.push({p: num, e: 1});
                            return factors;
                        }

                        function draw() {
                            viz.clear();
                            const ctx = viz.ctx;

                            const factors = primeFactorization(n);

                            // Draw main module
                            ctx.fillStyle = viz.colors.blue + '33';
                            ctx.strokeStyle = viz.colors.blue;
                            ctx.lineWidth = 2;
                            ctx.fillRect(50, 50, 200, 100);
                            ctx.strokeRect(50, 50, 200, 100);
                            ctx.fillStyle = viz.colors.white;
                            ctx.font = '18px monospace';
                            ctx.textAlign = 'center';
                            ctx.fillText('ℤ/' + n + 'ℤ', 150, 100);

                            // Draw arrow
                            ctx.strokeStyle = viz.colors.white;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(270, 100);
                            ctx.lineTo(320, 100);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(310, 95);
                            ctx.lineTo(320, 100);
                            ctx.lineTo(310, 105);
                            ctx.stroke();

                            ctx.font = '14px monospace';
                            ctx.fillText('≅', 295, 90);

                            // Draw primary components
                            const startX = 350;
                            const spacing = 150;
                            const colors = [viz.colors.orange, viz.colors.green, viz.colors.purple, viz.colors.pink];

                            factors.forEach((f, i) => {
                                const x = startX + i * spacing;
                                const color = colors[i % colors.length];

                                ctx.fillStyle = color + '33';
                                ctx.strokeStyle = color;
                                ctx.lineWidth = 2;
                                ctx.fillRect(x, 50, 120, 100);
                                ctx.strokeRect(x, 50, 120, 100);

                                ctx.fillStyle = viz.colors.white;
                                ctx.font = '16px monospace';
                                ctx.textAlign = 'center';
                                ctx.fillText('ℤ/' + Math.pow(f.p, f.e) + 'ℤ', x + 60, 95);
                                ctx.font = '12px monospace';
                                ctx.fillText(f.p + '-primary', x + 60, 115);

                                if (i < factors.length - 1) {
                                    ctx.fillStyle = viz.colors.text;
                                    ctx.fillText('⊕', x + 130, 100);
                                }
                            });

                            // Display factorization
                            ctx.fillStyle = viz.colors.text;
                            ctx.font = '14px monospace';
                            ctx.textAlign = 'left';
                            let factStr = n + ' = ' + factors.map(f => f.p + '^' + f.e).join(' · ');
                            ctx.fillText(factStr, 50, 200);
                        }

                        draw();
                        return viz;
                    }
                }
            ],
            exercises: [
                {
                    question: 'Find the primary decomposition of \\(\\mathbb{Z}/60\\mathbb{Z}\\) as a \\(\\mathbb{Z}\\)-module.',
                    hint: 'First factor 60 into prime powers.',
                    solution: 'Since \\(60 = 2^2 \\cdot 3 \\cdot 5\\), we have \\[\\mathbb{Z}/60\\mathbb{Z} \\cong \\mathbb{Z}/4\\mathbb{Z} \\oplus \\mathbb{Z}/3\\mathbb{Z} \\oplus \\mathbb{Z}/5\\mathbb{Z}\\] The 2-primary component is \\(\\mathbb{Z}/4\\mathbb{Z}\\), the 3-primary component is \\(\\mathbb{Z}/3\\mathbb{Z}\\), and the 5-primary component is \\(\\mathbb{Z}/5\\mathbb{Z}\\).'
                },
                {
                    question: 'Show that if \\(M = M_1 \\oplus M_2\\) where \\(M_1\\) is \\(p\\)-primary and \\(M_2\\) is \\(q\\)-primary for distinct primes \\(p, q\\), then \\(M_1 = \\{m \\in M : p^k m = 0 \\text{ for some } k\\}\\).',
                    hint: 'Use the fact that elements of \\(M_2\\) are annihilated by powers of \\(q\\), not \\(p\\).',
                    solution: 'Let \\(N = \\{m \\in M : p^k m = 0 \\text{ for some } k\\}\\). Clearly \\(M_1 \\subseteq N\\). For the reverse, if \\(m = m_1 + m_2 \\in N\\) with \\(m_i \\in M_i\\), then \\(p^k m = p^k m_1 + p^k m_2 = 0\\). Since \\(M_1\\) is \\(p\\)-primary, \\(p^\\ell m_1 = 0\\) for some \\(\\ell\\), so \\(p^{\\max(k,\\ell)} m_2 = -p^{\\max(k,\\ell)} m_1 = 0\\). But \\(M_2\\) is \\(q\\)-primary and \\(p, q\\) are coprime, so \\(m_2 = 0\\). Thus \\(m = m_1 \\in M_1\\).'
                },
                {
                    question: 'Prove that the primary decomposition is functorial: if \\(f: M \\to N\\) is a module homomorphism and \\(M = \\bigoplus M_{p_i}\\), \\(N = \\bigoplus N_{p_i}\\) are primary decompositions, then \\(f(M_{p_i}) \\subseteq N_{p_i}\\).',
                    hint: 'Show that \\(f\\) preserves the annihilator property.',
                    solution: 'If \\(m \\in M_{p_i}\\), then \\(p_i^k m = 0\\) for some \\(k\\). Since \\(f\\) is a homomorphism, \\(p_i^k f(m) = f(p_i^k m) = f(0) = 0\\). Thus \\(f(m)\\) is annihilated by a power of \\(p_i\\), which means \\(f(m) \\in N_{p_i}\\) by the uniqueness of primary decomposition.'
                }
            ]
        },
        {
            id: 'ch06-sec03',
            title: 'Cyclic Decomposition and Elementary Divisors',
            content: `
                <h2>Cyclic Decomposition and Elementary Divisors</h2>

                <div class="env-block definition">
                    <div class="env-title">Definition 6.12 (Cyclic Module)</div>
                    <div class="env-body">
                        <p>An \\(R\\)-module \\(M\\) is <strong>cyclic</strong> if it is generated by a single element, i.e., \\(M = \\langle m \\rangle = Rm\\) for some \\(m \\in M\\).</p>
                        <p>Note: Every cyclic module over a PID \\(R\\) has the form \\(M \\cong R/\\langle a \\rangle\\) for some \\(a \\in R\\).</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.13 (Cyclic Decomposition of Primary Modules)</div>
                    <div class="env-body">
                        <p>Let \\(M\\) be a finitely generated \\(p\\)-primary module over a PID \\(R\\), where \\(p\\) is prime. Then</p>
                        \\[M = \\langle m_1 \\rangle \\oplus \\cdots \\oplus \\langle m_k \\rangle\\]
                        <p>where \\(\\operatorname{ann}(\\langle m_i \\rangle) = \\langle p^{e_i} \\rangle\\) and \\(e_1 \\geq e_2 \\geq \\cdots \\geq e_k \\geq 1\\).</p>
                        <p>Moreover, the chain of annihilators \\(\\langle p^{e_1} \\rangle \\supseteq \\cdots \\supseteq \\langle p^{e_k} \\rangle\\) is uniquely determined by \\(M\\).</p>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 6.14 (Elementary Divisors)</div>
                    <div class="env-body">
                        <p>Let \\(M\\) be a finitely generated torsion module over a PID \\(R\\). The <strong>elementary divisors</strong> of \\(M\\) are the generators \\(p^e\\) of the annihilators of the cyclic summands in the primary cyclic decomposition</p>
                        \\[M = \\bigoplus_{i,j} \\langle m_{i,j} \\rangle\\]
                        <p>where \\(\\operatorname{ann}(\\langle m_{i,j} \\rangle) = \\langle p_i^{e_{i,j}} \\rangle\\).</p>
                        <p>The multiset of elementary divisors (counted with multiplicity) is denoted \\(\\text{ElemDiv}(M)\\).</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.15 (Elementary Divisors are Complete Invariants)</div>
                    <div class="env-body">
                        <p>Two finitely generated torsion modules \\(M\\) and \\(N\\) over a PID are isomorphic if and only if they have the same elementary divisors (counted with multiplicity):</p>
                        \\[M \\cong N \\quad \\iff \\quad \\text{ElemDiv}(M) = \\text{ElemDiv}(N)\\]
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.16 (Elementary Divisors)</div>
                    <div class="env-body">
                        <p>Consider the \\(\\mathbb{Z}\\)-module</p>
                        \\[M = \\mathbb{Z}/4\\mathbb{Z} \\oplus \\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/9\\mathbb{Z} \\oplus \\mathbb{Z}/3\\mathbb{Z}\\]
                        <p>The primary decomposition is</p>
                        \\[M = (\\mathbb{Z}/4\\mathbb{Z} \\oplus \\mathbb{Z}/2\\mathbb{Z}) \\oplus (\\mathbb{Z}/9\\mathbb{Z} \\oplus \\mathbb{Z}/3\\mathbb{Z})\\]
                        <p>The elementary divisors are \\(\\{2^2, 2^1, 3^2, 3^1\\} = \\{4, 2, 9, 3\\}\\).</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="elementary-divisors-viz"></div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.17 (Structure Theorem - Elementary Divisor Form)</div>
                    <div class="env-body">
                        <p>Every finitely generated module \\(M\\) over a PID \\(R\\) can be written uniquely (up to isomorphism and reordering) as</p>
                        \\[M \\cong R^r \\oplus R/\\langle d_1 \\rangle \\oplus \\cdots \\oplus R/\\langle d_k \\rangle\\]
                        <p>where \\(r \\geq 0\\) is the rank of the free part, and \\(d_1, \\ldots, d_k\\) are the elementary divisors (prime powers).</p>
                    </div>
                </div>

                <div class="env-block intuition">
                    <div class="env-title">Intuition: Building Blocks</div>
                    <div class="env-body">
                        <p>The elementary divisor decomposition says that every finitely generated module over a PID is built from two types of "building blocks":</p>
                        <ul>
                            <li><strong>Free parts:</strong> Copies of \\(R\\) (no torsion)</li>
                            <li><strong>Torsion parts:</strong> Cyclic modules \\(R/\\langle p^e \\rangle\\) for prime powers \\(p^e\\)</li>
                        </ul>
                        <p>This is completely analogous to how every finitely generated abelian group is a product of \\(\\mathbb{Z}\\)'s and cyclic groups of prime power order!</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'elementary-divisors-viz',
                    title: 'Interactive: Elementary Divisor Factorization',
                    description: 'See how elementary divisors factor into prime powers',
                    setup: function(container, controls) {
                        const viz = new VizEngine(container, {width: 700, height: 500, scale: 1});

                        const examples = [
                            {name: 'ℤ/12ℤ', divs: [12]},
                            {name: 'ℤ/4ℤ ⊕ ℤ/6ℤ', divs: [4, 6]},
                            {name: 'ℤ/8ℤ ⊕ ℤ/4ℤ ⊕ ℤ/2ℤ', divs: [8, 4, 2]},
                            {name: 'ℤ/30ℤ ⊕ ℤ/10ℤ', divs: [30, 10]},
                            {name: 'ℤ/36ℤ ⊕ ℤ/12ℤ ⊕ ℤ/4ℤ', divs: [36, 12, 4]}
                        ];

                        let exIdx = 0;

                        const prevBtn = VizEngine.createButton(controls, '← Prev', () => {
                            exIdx = (exIdx - 1 + examples.length) % examples.length;
                            draw();
                        });

                        const nextBtn = VizEngine.createButton(controls, 'Next →', () => {
                            exIdx = (exIdx + 1) % examples.length;
                            draw();
                        });

                        function primeFactorization(num) {
                            const factors = [];
                            let d = 2;
                            while (d * d <= num) {
                                let exp = 0;
                                while (num % d === 0) {
                                    exp++;
                                    num /= d;
                                }
                                if (exp > 0) factors.push({p: d, e: exp});
                                d++;
                            }
                            if (num > 1) factors.push({p: num, e: 1});
                            return factors;
                        }

                        function draw() {
                            viz.clear();
                            const ctx = viz.ctx;
                            const ex = examples[exIdx];

                            // Title
                            ctx.fillStyle = viz.colors.white;
                            ctx.font = 'bold 20px monospace';
                            ctx.textAlign = 'center';
                            ctx.fillText('Module: ' + ex.name, 350, 40);

                            // Draw each divisor and its factorization
                            const startY = 80;
                            const spacing = 100;

                            ex.divs.forEach((d, i) => {
                                const y = startY + i * spacing;

                                // Original divisor
                                ctx.fillStyle = viz.colors.blue + '33';
                                ctx.strokeStyle = viz.colors.blue;
                                ctx.lineWidth = 2;
                                ctx.fillRect(50, y, 120, 60);
                                ctx.strokeRect(50, y, 120, 60);

                                ctx.fillStyle = viz.colors.white;
                                ctx.font = '16px monospace';
                                ctx.textAlign = 'center';
                                ctx.fillText('ℤ/' + d + 'ℤ', 110, y + 35);

                                // Arrow
                                ctx.strokeStyle = viz.colors.white;
                                ctx.beginPath();
                                ctx.moveTo(190, y + 30);
                                ctx.lineTo(240, y + 30);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.moveTo(230, y + 25);
                                ctx.lineTo(240, y + 30);
                                ctx.lineTo(230, y + 35);
                                ctx.stroke();

                                // Prime factorization
                                const factors = primeFactorization(d);
                                const colors = [viz.colors.orange, viz.colors.green, viz.colors.purple];
                                let x = 260;

                                factors.forEach((f, j) => {
                                    const pe = Math.pow(f.p, f.e);
                                    const color = colors[j % colors.length];

                                    ctx.fillStyle = color + '33';
                                    ctx.strokeStyle = color;
                                    ctx.fillRect(x, y, 80, 60);
                                    ctx.strokeRect(x, y, 80, 60);

                                    ctx.fillStyle = viz.colors.white;
                                    ctx.font = '14px monospace';
                                    ctx.textAlign = 'center';
                                    ctx.fillText(f.p + '^' + f.e, x + 40, y + 25);
                                    ctx.font = '12px monospace';
                                    ctx.fillText('= ' + pe, x + 40, y + 45);

                                    x += 90;

                                    if (j < factors.length - 1) {
                                        ctx.fillStyle = viz.colors.text;
                                        ctx.fillText('×', x - 45, y + 30);
                                    }
                                });
                            });

                            // Summary
                            ctx.fillStyle = viz.colors.text;
                            ctx.font = '14px monospace';
                            ctx.textAlign = 'left';
                            const allFactors = ex.divs.flatMap(d => {
                                const fs = primeFactorization(d);
                                return fs.map(f => f.p + '^' + f.e);
                            });
                            ctx.fillText('Elementary divisors: {' + allFactors.join(', ') + '}', 50, startY + ex.divs.length * spacing + 30);
                        }

                        draw();
                        return viz;
                    }
                }
            ],
            exercises: [
                {
                    question: 'Find the elementary divisors of \\(M = \\mathbb{Z}/24\\mathbb{Z} \\oplus \\mathbb{Z}/18\\mathbb{Z}\\).',
                    hint: 'Factor each cyclic summand into its primary components first.',
                    solution: 'Since \\(24 = 2^3 \\cdot 3\\) and \\(18 = 2 \\cdot 3^2\\), we have \\[M \\cong (\\mathbb{Z}/8\\mathbb{Z} \\oplus \\mathbb{Z}/3\\mathbb{Z}) \\oplus (\\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/9\\mathbb{Z}) \\cong \\mathbb{Z}/8\\mathbb{Z} \\oplus \\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/9\\mathbb{Z} \\oplus \\mathbb{Z}/3\\mathbb{Z}\\] The elementary divisors are \\(\\{8, 2, 9, 3\\} = \\{2^3, 2^1, 3^2, 3^1\\}\\).'
                },
                {
                    question: 'Show that two finitely generated abelian groups are isomorphic if and only if they have the same elementary divisors.',
                    hint: 'Use the fact that finitely generated abelian groups are \\(\\mathbb{Z}\\)-modules.',
                    solution: 'This is a direct application of Theorem 6.15. Finitely generated abelian groups are precisely finitely generated \\(\\mathbb{Z}\\)-modules. The structure theorem says they are determined up to isomorphism by their elementary divisors (and the rank of the free part). Two such groups are isomorphic iff they have the same rank and the same multiset of elementary divisors.'
                },
                {
                    question: 'Prove that a cyclic module \\(M = \\langle m \\rangle\\) over a PID with \\(\\operatorname{ann}(m) = \\langle a \\rangle\\) is isomorphic to \\(R/\\langle a \\rangle\\).',
                    hint: 'Define \\(\\phi: R \\to M\\) by \\(\\phi(r) = rm\\) and use the first isomorphism theorem.',
                    solution: 'Define \\(\\phi: R \\to M\\) by \\(\\phi(r) = rm\\). This is a surjective \\(R\\)-module homomorphism since \\(M = \\langle m \\rangle\\). The kernel is \\(\\ker(\\phi) = \\{r \\in R : rm = 0\\} = \\operatorname{ann}(m) = \\langle a \\rangle\\). By the first isomorphism theorem, \\(M \\cong R/\\ker(\\phi) = R/\\langle a \\rangle\\).'
                }
            ]
        },
        {
            id: 'ch06-sec04',
            title: 'Invariant Factors',
            content: `
                <h2>Invariant Factors</h2>

                <p>While the elementary divisor form gives a complete classification, there is another canonical form called the <strong>invariant factor decomposition</strong> that is often more convenient for computation.</p>

                <div class="env-block definition">
                    <div class="env-title">Definition 6.18 (Invariant Factors)</div>
                    <div class="env-body">
                        <p>Let \\(M\\) be a finitely generated torsion module over a PID \\(R\\). An <strong>invariant factor decomposition</strong> of \\(M\\) is</p>
                        \\[M = \\langle c_1 \\rangle \\oplus \\cdots \\oplus \\langle c_k \\rangle\\]
                        <p>where \\(\\operatorname{ann}(\\langle c_i \\rangle) = \\langle \\tau_i \\rangle\\) and</p>
                        \\[\\tau_1 \\mid \\tau_2 \\mid \\cdots \\mid \\tau_k\\]
                        <p>The elements \\(\\tau_1, \\ldots, \\tau_k\\) are called the <strong>invariant factors</strong> of \\(M\\).</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.19 (Structure Theorem - Invariant Factor Form)</div>
                    <div class="env-body">
                        <p>Every finitely generated module \\(M\\) over a PID \\(R\\) can be written uniquely (up to isomorphism) as</p>
                        \\[M \\cong R^r \\oplus R/\\langle \\tau_1 \\rangle \\oplus \\cdots \\oplus R/\\langle \\tau_k \\rangle\\]
                        <p>where \\(r \\geq 0\\) and \\(\\tau_1 \\mid \\tau_2 \\mid \\cdots \\mid \\tau_k\\) are nonzero non-units.</p>
                        <p>The integer \\(r\\) is the rank and \\(\\tau_1, \\ldots, \\tau_k\\) are the invariant factors.</p>
                    </div>
                </div>

                <div class="env-block remark">
                    <div class="env-title">Remark: Converting Between Forms</div>
                    <div class="env-body">
                        <p><strong>Elementary divisors → Invariant factors:</strong></p>
                        <ol>
                            <li>Group elementary divisors by prime: \\(p_1^{e_{1,1}}, \\ldots, p_1^{e_{1,k_1}}\\); \\(p_2^{e_{2,1}}, \\ldots\\)</li>
                            <li>Within each group, arrange in descending order: \\(e_{i,1} \\geq e_{i,2} \\geq \\cdots\\)</li>
                            <li>Form products column-wise: \\(\\tau_j = p_1^{e_{1,j}} \\cdot p_2^{e_{2,j}} \\cdots\\) (using 0 for missing exponents)</li>
                        </ol>
                        <p><strong>Invariant factors → Elementary divisors:</strong></p>
                        <ol>
                            <li>Factor each \\(\\tau_i\\) into prime powers</li>
                            <li>Collect all prime powers (with multiplicity)</li>
                        </ol>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.20 (Converting Between Forms)</div>
                    <div class="env-body">
                        <p><strong>Elementary divisors to invariant factors:</strong></p>
                        <p>Suppose \\(\\text{ElemDiv}(M) = \\{2^3, 2^2, 2^1, 3^2, 3^1, 5^1\\}\\).</p>
                        <p>Arrange by prime:</p>
                        <ul>
                            <li>Prime 2: \\(2^3, 2^2, 2^1\\)</li>
                            <li>Prime 3: \\(3^2, 3^1\\)</li>
                            <li>Prime 5: \\(5^1\\)</li>
                        </ul>
                        <p>Form products column-wise:</p>
                        \\[\\begin{align}
                        \\tau_1 &= 2^3 \\cdot 3^2 \\cdot 5^1 = 8 \\cdot 9 \\cdot 5 = 360\\\\
                        \\tau_2 &= 2^2 \\cdot 3^1 \\cdot 5^0 = 4 \\cdot 3 \\cdot 1 = 12\\\\
                        \\tau_3 &= 2^1 \\cdot 3^0 \\cdot 5^0 = 2 \\cdot 1 \\cdot 1 = 2
                        \\end{align}\\]
                        <p>Check divisibility: \\(2 \\mid 12 \\mid 360\\). ✓</p>
                        <p>So \\(M \\cong \\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/12\\mathbb{Z} \\oplus \\mathbb{Z}/360\\mathbb{Z}\\) (invariant factor form).</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="invariant-factor-viz"></div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.21 (Uniqueness of Invariant Factors)</div>
                    <div class="env-body">
                        <p>The invariant factors of a finitely generated module over a PID are uniquely determined (up to associates).</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.22 (Classifying Abelian Groups of Order 72)</div>
                    <div class="env-body">
                        <p>Find all abelian groups of order 72 up to isomorphism.</p>
                        <p><strong>Solution:</strong> Since \\(72 = 2^3 \\cdot 3^2\\), we need all ways to partition the exponents.</p>
                        <p>For \\(2^3\\): partitions are \\((3)\\), \\((2,1)\\), \\((1,1,1)\\)</p>
                        <p>For \\(3^2\\): partitions are \\((2)\\), \\((1,1)\\)</p>
                        <p>This gives \\(3 \\times 2 = 6\\) groups. In invariant factor form:</p>
                        <ol>
                            <li>\\(\\mathbb{Z}/72\\mathbb{Z}\\) (elementary divisors: \\(2^3, 3^2\\))</li>
                            <li>\\(\\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/36\\mathbb{Z}\\) (elem. divs: \\(2^1, 2^2, 3^2\\))</li>
                            <li>\\(\\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/18\\mathbb{Z}\\) (elem. divs: \\(2^1, 2^1, 2^1, 3^2\\))</li>
                            <li>\\(\\mathbb{Z}/3\\mathbb{Z} \\oplus \\mathbb{Z}/24\\mathbb{Z}\\) (elem. divs: \\(2^3, 3^1, 3^1\\))</li>
                            <li>\\(\\mathbb{Z}/6\\mathbb{Z} \\oplus \\mathbb{Z}/12\\mathbb{Z}\\) (elem. divs: \\(2^1, 2^2, 3^1, 3^1\\))</li>
                            <li>\\(\\mathbb{Z}/6\\mathbb{Z} \\oplus \\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/6\\mathbb{Z}\\) (elem. divs: \\(2^1, 2^1, 2^1, 3^1, 3^1\\))</li>
                        </ol>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'invariant-factor-viz',
                    title: 'Interactive: Elementary Divisors ↔ Invariant Factors',
                    description: 'Convert between elementary divisor and invariant factor forms',
                    setup: function(container, controls) {
                        const viz = new VizEngine(container, {width: 700, height: 550, scale: 1});

                        const examples = [
                            {
                                name: 'Example 1',
                                ed: [[2,3], [2,2], [2,1], [3,2], [3,1], [5,1]],
                                if_result: [360, 12, 2]
                            },
                            {
                                name: 'Example 2',
                                ed: [[2,2], [2,1], [3,2]],
                                if_result: [12, 2]
                            },
                            {
                                name: 'Example 3',
                                ed: [[2,3], [3,2], [5,1]],
                                if_result: [120]
                            }
                        ];

                        let exIdx = 0;

                        const prevBtn = VizEngine.createButton(controls, '← Prev', () => {
                            exIdx = (exIdx - 1 + examples.length) % examples.length;
                            draw();
                        });

                        const nextBtn = VizEngine.createButton(controls, 'Next →', () => {
                            exIdx = (exIdx + 1) % examples.length;
                            draw();
                        });

                        function draw() {
                            viz.clear();
                            const ctx = viz.ctx;
                            const ex = examples[exIdx];

                            // Title
                            ctx.fillStyle = viz.colors.white;
                            ctx.font = 'bold 18px monospace';
                            ctx.textAlign = 'center';
                            ctx.fillText(ex.name, 350, 30);

                            // Elementary divisors
                            ctx.font = 'bold 16px monospace';
                            ctx.fillStyle = viz.colors.blue;
                            ctx.fillText('Elementary Divisors', 150, 70);

                            let y = 100;
                            ex.ed.forEach((pe, i) => {
                                ctx.fillStyle = viz.colors.orange + '44';
                                ctx.strokeStyle = viz.colors.orange;
                                ctx.lineWidth = 2;
                                ctx.fillRect(80, y, 140, 40);
                                ctx.strokeRect(80, y, 140, 40);

                                ctx.fillStyle = viz.colors.white;
                                ctx.font = '14px monospace';
                                ctx.textAlign = 'center';
                                const val = Math.pow(pe[0], pe[1]);
                                ctx.fillText(pe[0] + '^' + pe[1] + ' = ' + val, 150, y + 25);

                                y += 50;
                            });

                            // Group by prime
                            ctx.fillStyle = viz.colors.text;
                            ctx.font = '14px monospace';
                            ctx.textAlign = 'left';
                            ctx.fillText('Group by prime:', 80, y + 20);

                            const grouped = {};
                            ex.ed.forEach(pe => {
                                if (!grouped[pe[0]]) grouped[pe[0]] = [];
                                grouped[pe[0]].push(pe[1]);
                            });

                            // Sort exponents descending
                            for (let p in grouped) {
                                grouped[p].sort((a, b) => b - a);
                            }

                            y += 45;
                            const primes = Object.keys(grouped).map(Number).sort((a,b) => a-b);
                            primes.forEach(p => {
                                ctx.fillText('  ' + p + ': [' + grouped[p].join(', ') + ']', 80, y);
                                y += 25;
                            });

                            // Arrow
                            ctx.strokeStyle = viz.colors.white;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(250, 250);
                            ctx.lineTo(380, 250);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(370, 245);
                            ctx.lineTo(380, 250);
                            ctx.lineTo(370, 255);
                            ctx.stroke();

                            // Invariant factors
                            ctx.font = 'bold 16px monospace';
                            ctx.fillStyle = viz.colors.green;
                            ctx.textAlign = 'center';
                            ctx.fillText('Invariant Factors', 520, 70);

                            y = 100;
                            ex.if_result.forEach((tau, i) => {
                                ctx.fillStyle = viz.colors.teal + '44';
                                ctx.strokeStyle = viz.colors.teal;
                                ctx.lineWidth = 2;
                                ctx.fillRect(420, y, 200, 40);
                                ctx.strokeRect(420, y, 200, 40);

                                ctx.fillStyle = viz.colors.white;
                                ctx.font = '14px monospace';
                                ctx.textAlign = 'center';
                                ctx.fillText('τ_{' + (i+1) + '} = ' + tau, 520, y + 25);

                                y += 50;
                            });

                            // Check divisibility
                            ctx.fillStyle = viz.colors.text;
                            ctx.font = '14px monospace';
                            ctx.textAlign = 'center';
                            let divCheck = ex.if_result.join(' | ');
                            ctx.fillText('Divisibility: ' + divCheck, 350, 470);

                            // Show decomposition
                            ctx.fillText('Module: M ≅ ' + ex.if_result.map((t,i) => 'ℤ/' + t + 'ℤ').join(' ⊕'), 350, 510);
                        }

                        draw();
                        return viz;
                    }
                }
            ],
            exercises: [
                {
                    question: 'Find the invariant factors of \\(M = \\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/4\\mathbb{Z} \\oplus \\mathbb{Z}/8\\mathbb{Z} \\oplus \\mathbb{Z}/3\\mathbb{Z} \\oplus \\mathbb{Z}/9\\mathbb{Z}\\).',
                    hint: 'The elementary divisors are \\(\\{2, 4, 8, 3, 9\\} = \\{2^1, 2^2, 2^3, 3^1, 3^2\\}\\). Group by prime and form products column-wise.',
                    solution: 'Group by prime: 2: \\([3,2,1]\\), 3: \\([2,1]\\). Form products: \\(\\tau_1 = 2^3 \\cdot 3^2 = 72\\), \\(\\tau_2 = 2^2 \\cdot 3^1 = 12\\), \\(\\tau_3 = 2^1 = 2\\). Check: \\(2 \\mid 12 \\mid 72\\). Invariant factors are \\(\\{2, 12, 72\\}\\). So \\(M \\cong \\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/12\\mathbb{Z} \\oplus \\mathbb{Z}/72\\mathbb{Z}\\).'
                },
                {
                    question: 'How many non-isomorphic abelian groups of order 100 are there? List them.',
                    hint: '\\(100 = 2^2 \\cdot 5^2\\). Count partitions of the exponents.',
                    solution: 'Partitions of 2: \\((2)\\), \\((1,1)\\). So \\(2 \\times 2 = 4\\) groups total. Elementary divisor form: (1) \\(\\{2^2, 5^2\\}\\), (2) \\(\\{2^1, 2^1, 5^2\\}\\), (3) \\(\\{2^2, 5^1, 5^1\\}\\), (4) \\(\\{2^1, 2^1, 5^1, 5^1\\}\\). Invariant factor form: (1) \\(\\mathbb{Z}/100\\mathbb{Z}\\), (2) \\(\\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/50\\mathbb{Z}\\), (3) \\(\\mathbb{Z}/5\\mathbb{Z} \\oplus \\mathbb{Z}/20\\mathbb{Z}\\), (4) \\(\\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/5\\mathbb{Z} \\oplus \\mathbb{Z}/5\\mathbb{Z}\\).'
                },
                {
                    question: 'Prove that if \\(\\tau_1 \\mid \\tau_2 \\mid \\cdots \\mid \\tau_k\\) are the invariant factors of \\(M\\), then \\(\\tau_k\\) is the order of \\(M\\) (i.e., a generator of \\(\\operatorname{ann}(M)\\)).',
                    hint: 'Show that \\(\\tau_k\\) annihilates all of \\(M\\), and no smaller element does.',
                    solution: 'If \\(M = R/\\langle \\tau_1 \\rangle \\oplus \\cdots \\oplus R/\\langle \\tau_k \\rangle\\), then \\(\\tau_k\\) annihilates each summand (since \\(\\tau_i \\mid \\tau_k\\)), hence all of \\(M\\). So \\(\\langle \\tau_k \\rangle \\subseteq \\operatorname{ann}(M)\\). Conversely, if \\(a \\in \\operatorname{ann}(M)\\), then \\(a\\) annihilates the last summand \\(R/\\langle \\tau_k \\rangle\\), which means \\(\\tau_k \\mid a\\), i.e., \\(a \\in \\langle \\tau_k \\rangle\\). Thus \\(\\operatorname{ann}(M) = \\langle \\tau_k \\rangle\\).'
                }
            ]
        },
        {
            id: 'ch06-sec05',
            title: 'Smith Normal Form',
            content: `
                <h2>Smith Normal Form</h2>

                <p>The Smith normal form is a computational tool for finding the invariant factors of a module presented by a matrix. It is the analog of row reduction for matrices over a PID.</p>

                <div class="env-block definition">
                    <div class="env-title">Definition 6.23 (Elementary Operations)</div>
                    <div class="env-body">
                        <p>Let \\(A\\) be an \\(m \\times n\\) matrix over a PID \\(R\\). The <strong>elementary row and column operations</strong> are:</p>
                        <ol>
                            <li><strong>Type I:</strong> Swap two rows (or columns)</li>
                            <li><strong>Type II:</strong> Multiply a row (or column) by a unit \\(u \\in R^*\\)</li>
                            <li><strong>Type III:</strong> Add a scalar multiple of one row (or column) to another</li>
                        </ol>
                        <p>Two matrices are <strong>equivalent</strong> if one can be obtained from the other by elementary operations.</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.24 (Smith Normal Form)</div>
                    <div class="env-body">
                        <p>Let \\(A\\) be an \\(m \\times n\\) matrix over a PID \\(R\\). Then \\(A\\) is equivalent to a diagonal matrix</p>
                        \\[D = \\begin{pmatrix} d_1 & & & & \\\\ & d_2 & & & \\\\ & & \\ddots & & \\\\ & & & d_r & \\\\ & & & & 0 \\end{pmatrix}\\]
                        <p>where \\(d_1 \\mid d_2 \\mid \\cdots \\mid d_r\\) are nonzero non-units, and all other entries are zero. The matrix \\(D\\) is called the <strong>Smith normal form</strong> of \\(A\\), and the \\(d_i\\) are the <strong>invariant factors</strong>.</p>
                    </div>
                </div>

                <div class="env-block intuition">
                    <div class="env-title">Intuition</div>
                    <div class="env-body">
                        <p>Think of Smith normal form as "diagonal form" for matrices over PIDs. Just as we can diagonalize matrices over fields using row operations, we can put matrices over PIDs in Smith normal form using row and column operations.</p>
                        <p>The key difference: over a field, every nonzero element is a unit, so we can make all diagonal entries equal to 1. Over a PID, we can only ensure divisibility \\(d_1 \\mid d_2 \\mid \\cdots \\mid d_r\\).</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.25 (Computing Invariant Factors from Smith Normal Form)</div>
                    <div class="env-body">
                        <p>If \\(A\\) is the presentation matrix of a finitely generated \\(R\\)-module \\(M\\), i.e., \\(M = R^n / \\text{im}(A)\\), then the Smith normal form of \\(A\\) gives the structure of \\(M\\):</p>
                        \\[M \\cong R^{n-r} \\oplus R/\\langle d_1 \\rangle \\oplus \\cdots \\oplus R/\\langle d_r \\rangle\\]
                        <p>where \\(r\\) is the rank of \\(A\\) and \\(d_1, \\ldots, d_r\\) are the nonzero diagonal entries.</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.26 (Smith Normal Form over \\(\\mathbb{Z}\\))</div>
                    <div class="env-body">
                        <p>Find the Smith normal form of \\(A = \\begin{pmatrix} 2 & 4 & 8 \\\\ 4 & 8 & 12 \\end{pmatrix}\\) over \\(\\mathbb{Z}\\).</p>
                        <p><strong>Solution:</strong></p>
                        \\[\\begin{pmatrix} 2 & 4 & 8 \\\\ 4 & 8 & 12 \\end{pmatrix} \\xrightarrow{R_2 - 2R_1} \\begin{pmatrix} 2 & 4 & 8 \\\\ 0 & 0 & -4 \\end{pmatrix}\\]
                        \\[\\xrightarrow{C_2 - 2C_1} \\begin{pmatrix} 2 & 0 & 8 \\\\ 0 & 0 & -4 \\end{pmatrix} \\xrightarrow{C_3 - 4C_1} \\begin{pmatrix} 2 & 0 & 0 \\\\ 0 & 0 & -4 \\end{pmatrix}\\]
                        \\[\\xrightarrow{\\text{swap } C_2, C_3} \\begin{pmatrix} 2 & 0 & 0 \\\\ 0 & -4 & 0 \\end{pmatrix} \\xrightarrow{R_2 \\cdot (-1)} \\begin{pmatrix} 2 & 0 & 0 \\\\ 0 & 4 & 0 \\end{pmatrix}\\]
                        <p>Check divisibility: \\(2 \\mid 4\\). ✓ So the Smith normal form is \\(\\begin{pmatrix} 2 & 0 & 0 \\\\ 0 & 4 & 0 \\end{pmatrix}\\).</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="smith-form-viz"></div>

                <div class="env-block remark">
                    <div class="env-title">Remark: Applications</div>
                    <div class="env-body">
                        <p>Smith normal form has many applications:</p>
                        <ul>
                            <li><strong>Computing homology groups:</strong> In algebraic topology, homology groups are computed as quotients of free modules, and Smith normal form gives their structure.</li>
                            <li><strong>Solving Diophantine equations:</strong> Systems of linear Diophantine equations \\(Ax = b\\) can be analyzed using Smith normal form.</li>
                            <li><strong>Canonical forms for matrices:</strong> In Chapter 7, we'll use Smith normal form to derive the rational and Jordan canonical forms.</li>
                        </ul>
                    </div>
                </div>

                <div class="env-block warning">
                    <div class="env-title">Warning: The Algorithm Can Be Subtle</div>
                    <div class="env-body">
                        <p>Unlike row reduction over fields, the Smith normal form algorithm requires care:</p>
                        <ul>
                            <li>You must use <em>both</em> row and column operations</li>
                            <li>After clearing a row/column, you may need to revisit earlier entries if new gcd's appear</li>
                            <li>The divisibility condition \\(d_1 \\mid d_2 \\mid \\cdots\\) requires checking and adjusting</li>
                        </ul>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'smith-form-viz',
                    title: 'Interactive: Smith Normal Form Step-by-Step',
                    description: 'Watch the algorithm transform a matrix to Smith normal form',
                    setup: function(container, controls) {
                        const viz = new VizEngine(container, {width: 700, height: 500, scale: 1});

                        const examples = [
                            {
                                name: 'Example 1',
                                matrix: [[2, 4], [4, 8]],
                                steps: [
                                    {desc: 'Initial matrix', mat: [[2, 4], [4, 8]]},
                                    {desc: 'R₂ - 2R₁', mat: [[2, 4], [0, 0]]},
                                    {desc: 'C₂ - 2C₁', mat: [[2, 0], [0, 0]]},
                                    {desc: 'Smith form (d₁=2)', mat: [[2, 0], [0, 0]]}
                                ]
                            },
                            {
                                name: 'Example 2',
                                matrix: [[2, 4, 8], [4, 8, 12]],
                                steps: [
                                    {desc: 'Initial matrix', mat: [[2, 4, 8], [4, 8, 12]]},
                                    {desc: 'R₂ - 2R₁', mat: [[2, 4, 8], [0, 0, -4]]},
                                    {desc: 'C₂ - 2C₁', mat: [[2, 0, 8], [0, 0, -4]]},
                                    {desc: 'C₃ - 4C₁', mat: [[2, 0, 0], [0, 0, -4]]},
                                    {desc: 'Swap C₂,C₃', mat: [[2, 0, 0], [0, -4, 0]]},
                                    {desc: 'R₂ · (-1)', mat: [[2, 0, 0], [0, 4, 0]]},
                                    {desc: 'Smith form (d₁=2, d₂=4)', mat: [[2, 0, 0], [0, 4, 0]]}
                                ]
                            },
                            {
                                name: 'Example 3',
                                matrix: [[6, 4], [9, 6]],
                                steps: [
                                    {desc: 'Initial matrix', mat: [[6, 4], [9, 6]]},
                                    {desc: 'Swap C₁,C₂', mat: [[4, 6], [6, 9]]},
                                    {desc: 'C₂ - C₁', mat: [[4, 2], [6, 3]]},
                                    {desc: 'Swap C₁,C₂', mat: [[2, 4], [3, 6]]},
                                    {desc: 'R₂ - R₁', mat: [[2, 4], [1, 2]]},
                                    {desc: 'Swap R₁,R₂', mat: [[1, 2], [2, 4]]},
                                    {desc: 'R₂ - 2R₁', mat: [[1, 2], [0, 0]]},
                                    {desc: 'C₂ - 2C₁', mat: [[1, 0], [0, 0]]},
                                    {desc: 'Smith form (d₁=1)', mat: [[1, 0], [0, 0]]}
                                ]
                            }
                        ];

                        let exIdx = 0;
                        let stepIdx = 0;

                        const prevExBtn = VizEngine.createButton(controls, '← Prev Example', () => {
                            exIdx = (exIdx - 1 + examples.length) % examples.length;
                            stepIdx = 0;
                            draw();
                        });

                        const prevStepBtn = VizEngine.createButton(controls, '← Step', () => {
                            if (stepIdx > 0) {
                                stepIdx--;
                                draw();
                            }
                        });

                        const nextStepBtn = VizEngine.createButton(controls, 'Step →', () => {
                            const ex = examples[exIdx];
                            if (stepIdx < ex.steps.length - 1) {
                                stepIdx++;
                                draw();
                            }
                        });

                        const nextExBtn = VizEngine.createButton(controls, 'Next Example →', () => {
                            exIdx = (exIdx + 1) % examples.length;
                            stepIdx = 0;
                            draw();
                        });

                        function drawMatrix(ctx, mat, x, y, cellW, cellH, highlight) {
                            const m = mat.length;
                            const n = mat[0].length;

                            for (let i = 0; i < m; i++) {
                                for (let j = 0; j < n; j++) {
                                    const cx = x + j * cellW;
                                    const cy = y + i * cellH;

                                    // Cell background
                                    if (highlight && highlight.includes([i,j].toString())) {
                                        ctx.fillStyle = viz.colors.orange + '44';
                                    } else {
                                        ctx.fillStyle = viz.colors.blue + '22';
                                    }
                                    ctx.fillRect(cx, cy, cellW, cellH);

                                    // Border
                                    ctx.strokeStyle = viz.colors.text;
                                    ctx.lineWidth = 1;
                                    ctx.strokeRect(cx, cy, cellW, cellH);

                                    // Value
                                    ctx.fillStyle = viz.colors.white;
                                    ctx.font = '16px monospace';
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillText(mat[i][j].toString(), cx + cellW/2, cy + cellH/2);
                                }
                            }
                        }

                        function draw() {
                            viz.clear();
                            const ctx = viz.ctx;
                            const ex = examples[exIdx];
                            const step = ex.steps[stepIdx];

                            // Title
                            ctx.fillStyle = viz.colors.white;
                            ctx.font = 'bold 18px monospace';
                            ctx.textAlign = 'center';
                            ctx.fillText(ex.name, 350, 30);

                            // Progress
                            ctx.font = '14px monospace';
                            ctx.fillStyle = viz.colors.text;
                            ctx.fillText('Step ' + (stepIdx + 1) + ' of ' + ex.steps.length, 350, 60);

                            // Current step description
                            ctx.fillStyle = viz.colors.orange;
                            ctx.font = '16px monospace';
                            ctx.fillText(step.desc, 350, 100);

                            // Matrix
                            const cellW = 60;
                            const cellH = 50;
                            const mat = step.mat;
                            const matWidth = mat[0].length * cellW;
                            const matHeight = mat.length * cellH;
                            const startX = (700 - matWidth) / 2;
                            const startY = 150;

                            drawMatrix(ctx, mat, startX, startY, cellW, cellH);

                            // Show invariant factors if final step
                            if (stepIdx === ex.steps.length - 1) {
                                const invFactors = [];
                                for (let i = 0; i < Math.min(mat.length, mat[0].length); i++) {
                                    if (mat[i][i] !== 0) invFactors.push(mat[i][i]);
                                }

                                if (invFactors.length > 0) {
                                    ctx.fillStyle = viz.colors.green;
                                    ctx.font = 'bold 16px monospace';
                                    ctx.fillText('Invariant factors: {' + invFactors.join(', ') + '}', 350, startY + matHeight + 50);

                                    // Check divisibility
                                    let divOk = true;
                                    for (let i = 0; i < invFactors.length - 1; i++) {
                                        if (invFactors[i+1] % invFactors[i] !== 0) divOk = false;
                                    }

                                    ctx.fillStyle = divOk ? viz.colors.green : viz.colors.red;
                                    ctx.font = '14px monospace';
                                    const divText = invFactors.join(' | ');
                                    ctx.fillText(divText + (divOk ? ' ✓' : ' ✗'), 350, startY + matHeight + 80);
                                }
                            }
                        }

                        draw();
                        return viz;
                    }
                }
            ],
            exercises: [
                {
                    question: 'Find the Smith normal form of \\(A = \\begin{pmatrix} 6 & 9 \\\\ 4 & 6 \\end{pmatrix}\\) over \\(\\mathbb{Z}\\).',
                    hint: 'Start by making the (1,1) entry as small as possible using row/column operations.',
                    solution: 'Swap columns: \\(\\begin{pmatrix} 9 & 6 \\\\ 6 & 4 \\end{pmatrix}\\). \\(C_1 - C_2\\): \\(\\begin{pmatrix} 3 & 6 \\\\ 2 & 4 \\end{pmatrix}\\). Swap rows: \\(\\begin{pmatrix} 2 & 4 \\\\ 3 & 6 \\end{pmatrix}\\). \\(R_2 - R_1\\): \\(\\begin{pmatrix} 2 & 4 \\\\ 1 & 2 \\end{pmatrix}\\). Swap rows: \\(\\begin{pmatrix} 1 & 2 \\\\ 2 & 4 \\end{pmatrix}\\). \\(R_2 - 2R_1\\): \\(\\begin{pmatrix} 1 & 2 \\\\ 0 & 0 \\end{pmatrix}\\). \\(C_2 - 2C_1\\): \\(\\begin{pmatrix} 1 & 0 \\\\ 0 & 0 \\end{pmatrix}\\).'
                },
                {
                    question: 'Let \\(M = \\mathbb{Z}^3 / \\text{im}(A)\\) where \\(A = \\begin{pmatrix} 2 & 4 \\\\ 0 & 6 \\\\ 0 & 0 \\end{pmatrix}\\). Find the structure of \\(M\\).',
                    hint: 'First find the Smith normal form of \\(A\\). The module structure is determined by the nonzero diagonal entries.',
                    solution: 'Start with \\(A = \\begin{pmatrix} 2 & 4 \\\\ 0 & 6 \\\\ 0 & 0 \\end{pmatrix}\\). \\(C_2 - 2C_1\\): \\(\\begin{pmatrix} 2 & 0 \\\\ 0 & 6 \\\\ 0 & 0 \\end{pmatrix}\\). This is in Smith form with \\(d_1 = 2, d_2 = 6\\). We need \\(d_1 | d_2\\), which holds. Thus \\(M \\cong \\mathbb{Z}^{3-2} \\oplus \\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/6\\mathbb{Z} = \\mathbb{Z} \\oplus \\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/6\\mathbb{Z}\\).'
                },
                {
                    question: 'Prove that elementary row operations on \\(A\\) correspond to left multiplication by invertible matrices, and elementary column operations correspond to right multiplication.',
                    hint: 'Consider what happens when you multiply \\(A\\) by an elementary matrix.',
                    solution: 'An elementary row operation of type I (swap rows \\(i,j\\)) is \\(E_{ij} A\\) where \\(E_{ij}\\) is the permutation matrix. Type II (multiply row \\(i\\) by unit \\(u\\)) is \\(E_i(u) A\\) where \\(E_i(u)\\) has \\(u\\) in position \\((i,i)\\) and 1 elsewhere on diagonal. Type III (add \\(r\\) times row \\(j\\) to row \\(i\\)) is \\(E_{ij}(r) A\\) where \\(E_{ij}(r)\\) is identity plus \\(r\\) in position \\((i,j)\\). All these matrices are invertible. Column operations are similar but with right multiplication \\(AE\\).'
                }
            ]
        },
        {
            id: 'ch06-sec06',
            title: 'Applications to Abelian Groups',
            content: `
                <h2>Applications to Abelian Groups</h2>

                <p>The structure theorem for modules over PIDs has immediate and powerful applications to the classification of finitely generated abelian groups.</p>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.27 (Fundamental Theorem of Finitely Generated Abelian Groups)</div>
                    <div class="env-body">
                        <p>Every finitely generated abelian group \\(G\\) is isomorphic to a direct sum</p>
                        \\[G \\cong \\mathbb{Z}^r \\oplus \\mathbb{Z}/n_1\\mathbb{Z} \\oplus \\cdots \\oplus \\mathbb{Z}/n_k\\mathbb{Z}\\]
                        <p>where \\(r \\geq 0\\) and \\(n_1 \\mid n_2 \\mid \\cdots \\mid n_k\\) are positive integers \\(\\geq 2\\).</p>
                        <p>The integer \\(r\\) is called the <strong>rank</strong> of \\(G\\), and \\(n_1, \\ldots, n_k\\) are the <strong>invariant factors</strong>. These are uniquely determined.</p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof</div>
                    <div class="env-body">
                        <p>Every finitely generated abelian group \\(G\\) is a finitely generated \\(\\mathbb{Z}\\)-module (with \\(n \\cdot g = g + \\cdots + g\\), \\(n\\) times). Since \\(\\mathbb{Z}\\) is a PID, Theorem 6.19 applies directly, giving the desired decomposition.</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.28 (All Abelian Groups of Order 12)</div>
                    <div class="env-body">
                        <p>Find all abelian groups of order 12 up to isomorphism.</p>
                        <p><strong>Solution:</strong> Since \\(12 = 2^2 \\cdot 3\\), we partition the exponents:</p>
                        <ul>
                            <li>For \\(2^2\\): partitions are \\((2)\\) and \\((1,1)\\)</li>
                            <li>For \\(3^1\\): partition is \\((1)\\)</li>
                        </ul>
                        <p>This gives 2 groups:</p>
                        <ol>
                            <li>\\(\\mathbb{Z}/12\\mathbb{Z}\\) (elementary divisors: \\(\\{4, 3\\}\\), invariant factor: 12)</li>
                            <li>\\(\\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/6\\mathbb{Z}\\) (elementary divisors: \\(\\{2, 2, 3\\}\\), invariant factors: 2, 6)</li>
                        </ol>
                        <p>Note: \\(\\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/6\\mathbb{Z} \\cong \\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/3\\mathbb{Z}\\) (elementary divisor form).</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.29 (Subgroups of \\(\\mathbb{Z}^n\\))</div>
                    <div class="env-body">
                        <p>Every subgroup \\(H\\) of \\(\\mathbb{Z}^n\\) is free of rank \\(\\leq n\\). This follows from Theorem 6.4.</p>
                        <p>For instance, \\(H = \\{(2a, 3b) : a,b \\in \\mathbb{Z}\\}\\) is a subgroup of \\(\\mathbb{Z}^2\\) with basis \\(\\{(2,0), (0,3)\\}\\).</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="abelian-group-viz"></div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.30 (Cyclic Groups)</div>
                    <div class="env-body">
                        <p>A finite abelian group \\(G\\) is cyclic if and only if it has only one invariant factor, i.e., \\(G \\cong \\mathbb{Z}/n\\mathbb{Z}\\).</p>
                        <p>Equivalently, \\(G\\) is cyclic iff for each prime \\(p\\), the \\(p\\)-primary component has at most one elementary divisor.</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.31 (When is \\(\\mathbb{Z}/m\\mathbb{Z} \\oplus \\mathbb{Z}/n\\mathbb{Z}\\) cyclic?)</div>
                    <div class="env-body">
                        <p>\\(\\mathbb{Z}/m\\mathbb{Z} \\oplus \\mathbb{Z}/n\\mathbb{Z} \\cong \\mathbb{Z}/\\text{lcm}(m,n)\\mathbb{Z}\\) if and only if \\(\\gcd(m,n) = 1\\).</p>
                        <p><strong>Proof:</strong> If \\(\\gcd(m,n) = 1\\), then by the Chinese Remainder Theorem,</p>
                        \\[\\mathbb{Z}/mn\\mathbb{Z} \\cong \\mathbb{Z}/m\\mathbb{Z} \\oplus \\mathbb{Z}/n\\mathbb{Z}\\]
                        <p>and \\(\\text{lcm}(m,n) = mn\\).</p>
                        <p>Conversely, if \\(d = \\gcd(m,n) > 1\\), then the invariant factors are \\(\\frac{mn}{d}, d\\) (not a single factor), so the group is not cyclic.</p>
                    </div>
                </div>

                <div class="env-block remark">
                    <div class="env-title">Remark: Counting Abelian Groups</div>
                    <div class="env-body">
                        <p>The number of abelian groups of order \\(n = p_1^{e_1} \\cdots p_k^{e_k}\\) is</p>
                        \\[P(e_1) \\cdot P(e_2) \\cdots P(e_k)\\]
                        <p>where \\(P(e)\\) is the partition function (number of partitions of \\(e\\)).</p>
                        <p>For example, \\(P(1) = 1\\), \\(P(2) = 2\\), \\(P(3) = 3\\), \\(P(4) = 5\\), etc.</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.32 (Automorphism Group)</div>
                    <div class="env-body">
                        <p>The automorphism group of \\(\\mathbb{Z}/n\\mathbb{Z}\\) is isomorphic to \\((\\mathbb{Z}/n\\mathbb{Z})^*\\), the group of units mod \\(n\\).</p>
                        <p>An automorphism \\(\\phi: \\mathbb{Z}/n\\mathbb{Z} \\to \\mathbb{Z}/n\\mathbb{Z}\\) is determined by \\(\\phi(1)\\), which must be a generator, i.e., \\(\\gcd(\\phi(1), n) = 1\\).</p>
                        <p>The order of \\(\\text{Aut}(\\mathbb{Z}/n\\mathbb{Z})\\) is \\(\\varphi(n)\\), the Euler phi function.</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'abelian-group-viz',
                    title: 'Interactive: Classify Abelian Groups of Order n',
                    description: 'Find all abelian groups of a given order',
                    setup: function(container, controls) {
                        const viz = new VizEngine(container, {width: 700, height: 500, scale: 1});

                        let n = 12;
                        const slider = VizEngine.createSlider(controls, 'n = ' + n, 2, 100, 12, 1, (val) => {
                            n = val;
                            slider.previousElementSibling.textContent = 'n = ' + n;
                            draw();
                        });

                        function primeFactorization(num) {
                            const factors = [];
                            let d = 2;
                            while (d * d <= num) {
                                let exp = 0;
                                while (num % d === 0) {
                                    exp++;
                                    num /= d;
                                }
                                if (exp > 0) factors.push({p: d, e: exp});
                                d++;
                            }
                            if (num > 1) factors.push({p: num, e: 1});
                            return factors;
                        }

                        function partitions(n) {
                            const result = [];
                            function helper(target, max, current) {
                                if (target === 0) {
                                    result.push([...current]);
                                    return;
                                }
                                for (let i = Math.min(max, target); i >= 1; i--) {
                                    current.push(i);
                                    helper(target - i, i, current);
                                    current.pop();
                                }
                            }
                            helper(n, n, []);
                            return result;
                        }

                        function generateGroups(n) {
                            const pf = primeFactorization(n);
                            if (pf.length === 0) return [];

                            // Get all partition combinations
                            const partitionSets = pf.map(f => partitions(f.e).map(part => ({p: f.p, parts: part})));

                            // Cartesian product
                            function cartesian(sets) {
                                if (sets.length === 0) return [[]];
                                const [first, ...rest] = sets;
                                const restProduct = cartesian(rest);
                                const result = [];
                                for (const item of first) {
                                    for (const restItem of restProduct) {
                                        result.push([item, ...restItem]);
                                    }
                                }
                                return result;
                            }

                            const combos = cartesian(partitionSets);

                            // Convert each combo to invariant factors
                            return combos.map(combo => {
                                // combo is array of {p, parts: [partition]}
                                const maxLen = Math.max(...combo.map(c => c.parts.length));
                                const invFactors = [];

                                for (let i = 0; i < maxLen; i++) {
                                    let factor = 1;
                                    combo.forEach(c => {
                                        const exp = c.parts[i] || 0;
                                        factor *= Math.pow(c.p, exp);
                                    });
                                    if (factor > 1) invFactors.push(factor);
                                }

                                invFactors.sort((a, b) => a - b);
                                return invFactors;
                            });
                        }

                        function draw() {
                            viz.clear();
                            const ctx = viz.ctx;

                            const pf = primeFactorization(n);
                            const groups = generateGroups(n);

                            // Title
                            ctx.fillStyle = viz.colors.white;
                            ctx.font = 'bold 20px monospace';
                            ctx.textAlign = 'center';
                            ctx.fillText('Abelian Groups of Order ' + n, 350, 30);

                            // Factorization
                            ctx.font = '14px monospace';
                            ctx.fillStyle = viz.colors.text;
                            const factStr = n + ' = ' + pf.map(f => f.p + '^' + f.e).join(' · ');
                            ctx.fillText(factStr, 350, 60);

                            // Number of groups
                            ctx.fillStyle = viz.colors.orange;
                            ctx.font = 'bold 16px monospace';
                            ctx.fillText('Total: ' + groups.length + ' group' + (groups.length !== 1 ? 's' : ''), 350, 90);

                            // List groups
                            const startY = 120;
                            const lineHeight = 35;

                            groups.forEach((invFactors, i) => {
                                const y = startY + i * lineHeight;

                                // Background
                                ctx.fillStyle = viz.colors.blue + '22';
                                ctx.fillRect(50, y - 20, 600, 30);

                                // Number
                                ctx.fillStyle = viz.colors.white;
                                ctx.font = 'bold 14px monospace';
                                ctx.textAlign = 'left';
                                ctx.fillText((i + 1) + '.', 60, y);

                                // Invariant factor form
                                ctx.font = '14px monospace';
                                let text = '';
                                if (invFactors.length === 0) {
                                    text = 'trivial group';
                                } else {
                                    text = invFactors.map(d => 'ℤ/' + d + 'ℤ').join(' ⊕ ');
                                }
                                ctx.fillText(text, 100, y);

                                // Check if cyclic
                                if (invFactors.length === 1) {
                                    ctx.fillStyle = viz.colors.green;
                                    ctx.fillText('(cyclic)', 520, y);
                                }
                            });

                            // Message if too many
                            if (groups.length > 12) {
                                ctx.fillStyle = viz.colors.red;
                                ctx.font = '12px monospace';
                                ctx.textAlign = 'center';
                                ctx.fillText('(showing first 12 only)', 350, startY + 12 * lineHeight + 20);
                            }
                        }

                        draw();
                        return viz;
                    }
                }
            ],
            exercises: [
                {
                    question: 'Find all abelian groups of order 36 up to isomorphism.',
                    hint: '\\(36 = 2^2 \\cdot 3^2\\). Find partitions of the exponents.',
                    solution: 'Partitions of 2: \\((2), (1,1)\\). So \\(2 \\times 2 = 4\\) groups: (1) \\(\\mathbb{Z}/36\\mathbb{Z}\\), (2) \\(\\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/18\\mathbb{Z}\\), (3) \\(\\mathbb{Z}/3\\mathbb{Z} \\oplus \\mathbb{Z}/12\\mathbb{Z}\\), (4) \\(\\mathbb{Z}/6\\mathbb{Z} \\oplus \\mathbb{Z}/6\\mathbb{Z}\\).'
                },
                {
                    question: 'Prove that if \\(G\\) is a finite abelian group and \\(p\\) is prime, then the number of elements of order \\(p\\) in \\(G\\) is \\(0\\) or \\(p^k - 1\\) for some \\(k \\geq 1\\).',
                    hint: 'Consider the \\(p\\)-primary component of \\(G\\).',
                    solution: 'Let \\(G_p\\) be the \\(p\\)-primary component. Elements of order \\(p\\) in \\(G\\) are exactly the elements of order \\(p\\) in \\(G_p\\). Write \\(G_p = \\mathbb{Z}/p^{e_1}\\mathbb{Z} \\oplus \\cdots \\oplus \\mathbb{Z}/p^{e_k}\\mathbb{Z}\\). An element \\((a_1, \\ldots, a_k)\\) has order \\(p\\) iff each \\(a_i \\in p^{e_i-1}\\mathbb{Z}/p^{e_i}\\mathbb{Z}\\) and not all \\(a_i = 0\\). Each component has \\(p\\) choices (including 0), giving \\(p^k\\) total, minus the zero element gives \\(p^k - 1\\).'
                },
                {
                    question: 'Show that \\(\\text{Aut}(\\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/2\\mathbb{Z}) \\cong S_3\\), the symmetric group on 3 elements.',
                    hint: 'An automorphism permutes the three nonzero elements (which all have order 2).',
                    solution: 'Let \\(G = \\mathbb{Z}/2\\mathbb{Z} \\oplus \\mathbb{Z}/2\\mathbb{Z} = \\{0, e_1, e_2, e_1+e_2\\}\\). Any automorphism must permute the three nonzero elements (since they all have order 2). Moreover, any permutation of \\(\\{e_1, e_2, e_1+e_2\\}\\) extends to an automorphism (since \\(e_1, e_2\\) generate and relations are preserved). Thus \\(\\text{Aut}(G) \\cong S_3\\). Note \\(|S_3| = 6 = |\\text{GL}_2(\\mathbb{F}_2)|\\), confirming this.'
                }
            ]
        },
        {
            id: 'ch06-sec07',
            title: 'Applications to Linear Algebra',
            content: `
                <h2>Applications to Linear Algebra</h2>

                <p>The theory of modules over PIDs has profound applications to linear algebra, particularly in understanding the structure of linear operators.</p>

                <div class="env-block intuition">
                    <div class="env-title">The Big Picture</div>
                    <div class="env-body">
                        <p>Given a linear operator \\(T: V \\to V\\) on a finite-dimensional vector space \\(V\\) over a field \\(F\\), we can view \\(V\\) as an \\(F[x]\\)-module where:</p>
                        \\[p(x) \\cdot v = p(T)(v)\\]
                        <p>Since \\(F[x]\\) is a PID, the structure theorem applies, giving canonical forms for \\(T\\)!</p>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 6.33 (\\(F[x]\\)-Module Structure)</div>
                    <div class="env-body">
                        <p>Let \\(T: V \\to V\\) be a linear operator. Define an \\(F[x]\\)-module structure on \\(V\\) by:</p>
                        \\[p(x) \\cdot v = p(T)(v)\\]
                        <p>for \\(p(x) \\in F[x]\\) and \\(v \\in V\\). We denote this module by \\(V_T\\).</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.34 (Rational Canonical Form - Preview)</div>
                    <div class="env-body">
                        <p>Applying the invariant factor decomposition to \\(V_T\\) gives:</p>
                        \\[V_T \\cong F[x]/\\langle \\tau_1(x) \\rangle \\oplus \\cdots \\oplus F[x]/\\langle \\tau_k(x) \\rangle\\]
                        <p>where \\(\\tau_1(x) \\mid \\tau_2(x) \\mid \\cdots \\mid \\tau_k(x)\\) are monic polynomials.</p>
                        <p>This leads to the <strong>rational canonical form</strong> of \\(T\\), which we'll study in Chapter 7.</p>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 6.35 (Minimal Polynomial)</div>
                    <div class="env-body">
                        <p>The <strong>minimal polynomial</strong> of \\(T\\) is the monic generator of \\(\\text{ann}(V_T)\\), i.e., the unique monic polynomial \\(m_T(x)\\) of smallest degree such that \\(m_T(T) = 0\\).</p>
                        <p>From the structure theorem, \\(m_T(x) = \\tau_k(x)\\), the largest invariant factor.</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.36 (Cayley-Hamilton Theorem)</div>
                    <div class="env-body">
                        <p>Every square matrix \\(A\\) satisfies its characteristic polynomial: if \\(p_A(x) = \\det(xI - A)\\), then</p>
                        \\[p_A(A) = 0\\]
                        <p>This follows from the structure theorem: the minimal polynomial \\(m_A(x)\\) divides the characteristic polynomial \\(p_A(x)\\).</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.37 (Nilpotent Operator)</div>
                    <div class="env-body">
                        <p>Let \\(T: \\mathbb{R}^3 \\to \\mathbb{R}^3\\) be the operator with matrix</p>
                        \\[A = \\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 0 & 0 \\end{pmatrix}\\]
                        <p>Then \\(T^3 = 0\\), so the minimal polynomial divides \\(x^3\\). In fact, \\(m_T(x) = x^3\\) since \\(T^2 \\neq 0\\).</p>
                        <p>The \\(\\mathbb{R}[x]\\)-module structure is \\(V_T \\cong \\mathbb{R}[x]/\\langle x^3 \\rangle\\), a single cyclic module.</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="module-linear-op-viz"></div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 6.38 (Diagonalization)</div>
                    <div class="env-body">
                        <p>A linear operator \\(T\\) is diagonalizable if and only if its minimal polynomial is a product of distinct linear factors:</p>
                        \\[m_T(x) = (x - \\lambda_1) \\cdots (x - \\lambda_k)\\]
                        <p>where \\(\\lambda_i\\) are distinct eigenvalues.</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 6.39 (Jordan Form Preview)</div>
                    <div class="env-body">
                        <p>Over \\(\\mathbb{C}\\), the elementary divisor form gives the Jordan canonical form:</p>
                        <p>If the elementary divisors of \\(V_T\\) are \\((x-\\lambda_1)^{e_1}, \\ldots, (x-\\lambda_k)^{e_k}\\), then \\(T\\) has Jordan blocks of sizes \\(e_1, \\ldots, e_k\\) with eigenvalues \\(\\lambda_1, \\ldots, \\lambda_k\\).</p>
                    </div>
                </div>

                <div class="env-block remark">
                    <div class="env-title">Remark: The Power of Abstraction</div>
                    <div class="env-body">
                        <p>By viewing linear algebra through the lens of modules over \\(F[x]\\), we:</p>
                        <ul>
                            <li>Unify many canonical forms (rational, Jordan, etc.)</li>
                            <li>Gain a conceptual understanding of similarity invariants</li>
                            <li>Connect linear algebra to other areas (topology, representation theory)</li>
                        </ul>
                        <p>This is a beautiful example of how abstraction clarifies and unifies!</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'module-linear-op-viz',
                    title: 'Interactive: V as an F[x]-Module',
                    description: 'See how polynomial multiplication acts on vectors',
                    setup: function(container, controls) {
                        const viz = new VizEngine(container, {width: 600, height: 450, scale: 40});

                        // Define a simple 2D linear transformation
                        let matrix = [[0.7, -0.3], [0.5, 0.7]]; // rotation + scaling
                        let v = viz.addDraggable('v', 2, 1, viz.colors.blue, 8, () => draw());

                        let degree = 0;
                        const degreeSlider = VizEngine.createSlider(controls, 'Degree: ' + degree, 0, 5, 0, 1, (val) => {
                            degree = val;
                            degreeSlider.previousElementSibling.textContent = 'Degree: ' + degree;
                            draw();
                        });

                        VizEngine.createButton(controls, 'Reset v', () => {
                            v.x = 2;
                            v.y = 1;
                            draw();
                        });

                        function applyMatrix(mat, vec) {
                            return [
                                mat[0][0] * vec[0] + mat[0][1] * vec[1],
                                mat[1][0] * vec[0] + mat[1][1] * vec[1]
                            ];
                        }

                        function matrixPower(mat, n) {
                            if (n === 0) return [[1, 0], [0, 1]];
                            if (n === 1) return mat;
                            let result = [[1, 0], [0, 1]];
                            for (let i = 0; i < n; i++) {
                                const newResult = [[0, 0], [0, 0]];
                                for (let r = 0; r < 2; r++) {
                                    for (let c = 0; c < 2; c++) {
                                        for (let k = 0; k < 2; k++) {
                                            newResult[r][c] += result[r][k] * mat[k][c];
                                        }
                                    }
                                }
                                result = newResult;
                            }
                            return result;
                        }

                        function draw() {
                            viz.clear();
                            viz.drawGrid();
                            viz.drawAxes();

                            const vec = [v.x, v.y];

                            // Show orbit: v, T(v), T²(v), ..., T^degree(v)
                            const colors = [
                                viz.colors.blue,
                                viz.colors.orange,
                                viz.colors.green,
                                viz.colors.purple,
                                viz.colors.pink,
                                viz.colors.yellow
                            ];

                            let currentVec = vec;
                            for (let i = 0; i <= degree; i++) {
                                const mat = matrixPower(matrix, i);
                                const result = applyMatrix(mat, vec);

                                viz.drawVector(0, 0, result[0], result[1], colors[i % colors.length], 'T^' + i + '(v)', 2);
                                viz.drawPoint(result[0], result[1], colors[i % colors.length], null, 6);
                            }

                            viz.drawDraggables();

                            // Info text
                            viz.drawText('Action of x^' + degree + ' on v', -7, 6, viz.colors.text, 14, 'left');
                            viz.drawText('(as F[x]-module)', -7, 5.3, viz.colors.text, 12, 'left');

                            // Show polynomial
                            viz.drawText('x^' + degree + ' · v = T^' + degree + '(v)', -7, -6, viz.colors.orange, 14, 'left');
                        }

                        draw();
                        return viz;
                    }
                }
            ],
            exercises: [
                {
                    question: 'Show that if \\(T: V \\to V\\) is a linear operator with minimal polynomial \\(m_T(x) = (x-2)(x-3)\\), then \\(T\\) is diagonalizable.',
                    hint: 'Use the fact that \\(m_T(x)\\) has no repeated roots.',
                    solution: 'Since \\(m_T(x) = (x-2)(x-3)\\) is a product of distinct linear factors, \\(T\\) is diagonalizable. The eigenvalues are 2 and 3. In the module decomposition, \\(V_T\\) is a direct sum of cyclic modules with annihilators dividing \\((x-2)\\) or \\((x-3)\\), which means each summand is 1-dimensional.'
                },
                {
                    question: 'Let \\(T: \\mathbb{R}^3 \\to \\mathbb{R}^3\\) have minimal polynomial \\(m_T(x) = x^2\\). What are the possible Jordan forms of \\(T\\)?',
                    hint: 'The elementary divisors must divide \\(x^2\\) and the largest must be \\(x^2\\).',
                    solution: 'The elementary divisors divide \\(m_T(x) = x^2\\) and one must equal \\(x^2\\) (the largest invariant factor). Since \\(\\dim V = 3\\), the possible elementary divisor sets are: (1) \\(\\{x^2, x^1\\}\\) giving Jordan form \\(\\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\\), or (2) three copies of \\(x^1\\) would give minimal polynomial \\(x\\), contradiction. So only one Jordan form is possible.'
                },
                {
                    question: 'Prove that the minimal polynomial \\(m_T(x)\\) divides any polynomial \\(p(x)\\) such that \\(p(T) = 0\\).',
                    hint: 'Use division algorithm in \\(F[x]\\): \\(p(x) = q(x) m_T(x) + r(x)\\) with \\(\\deg r < \\deg m_T\\).',
                    solution: 'By the division algorithm, \\(p(x) = q(x) m_T(x) + r(x)\\) where \\(\\deg r < \\deg m_T\\) or \\(r = 0\\). Applying to \\(T\\): \\(0 = p(T) = q(T) m_T(T) + r(T) = r(T)\\). By minimality of \\(\\deg m_T\\), we must have \\(r = 0\\), so \\(m_T(x) \\mid p(x)\\).'
                }
            ]
        }
    ]
});
