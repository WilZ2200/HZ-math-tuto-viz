// === Chapter 5: Modules II - Free and Noetherian Modules ===
// Extra Interactive Visualizations

window.EXTRA_VIZ = window.EXTRA_VIZ || {};
window.EXTRA_VIZ['ch05'] = window.EXTRA_VIZ['ch05'] || {};

// === Free Modules Visualizations ===
window.EXTRA_VIZ['ch05']['ch05-sec01'] = [
    {
        id: 'ch05-extra-viz-1',
        title: 'Free Module as Lattice Points',
        description: 'Visualize a free Z-module as lattice points generated by basis vectors. Drag the basis vectors to see how the lattice transforms.',
        setup: function(container, controls) {
            const viz = new VizEngine(container, {width: 560, height: 400, scale: 35});

            const b1 = viz.addDraggable('b1', 2, 1, viz.colors.blue, 8, () => draw());
            const b2 = viz.addDraggable('b2', -1, 2.5, viz.colors.orange, 8, () => draw());

            let showLabels = true;
            VizEngine.createButton(controls, 'Toggle Labels', () => {
                showLabels = !showLabels;
                draw();
            });

            function draw() {
                viz.clear();
                viz.drawGrid();
                viz.drawAxes();

                // Draw lattice points: all integer combinations of b1 and b2
                const range = 6;
                const points = [];
                for (let a = -range; a <= range; a++) {
                    for (let b = -range; b <= range; b++) {
                        const x = a * b1.x + b * b2.x;
                        const y = a * b1.y + b * b2.y;
                        // Check if point is within visible area
                        const [sx, sy] = viz.toScreen(x, y);
                        if (sx >= 0 && sx <= viz.width && sy >= 0 && sy <= viz.height) {
                            points.push({x, y, a, b});
                        }
                    }
                }

                // Draw fundamental parallelogram
                viz.drawPolygon([
                    [0, 0],
                    [b1.x, b1.y],
                    [b1.x + b2.x, b1.y + b2.y],
                    [b2.x, b2.y]
                ], viz.colors.purple + '11', viz.colors.purple + '44', 1.5);

                // Draw lattice points
                for (const p of points) {
                    const color = (p.a === 0 && p.b === 0) ? viz.colors.white : viz.colors.teal;
                    viz.drawPoint(p.x, p.y, color + '88', null, 4);
                }

                // Draw basis vectors
                viz.drawVector(0, 0, b1.x, b1.y, viz.colors.blue, 'b₁', 3);
                viz.drawVector(0, 0, b2.x, b2.y, viz.colors.orange, 'b₂', 3);

                // Show rank info
                const det = b1.x * b2.y - b1.y * b2.x;
                viz.drawText('Free ℤ-module, rank 2', -7, 5.5, viz.colors.white, 12, 'left');
                viz.drawText('det = ' + det.toFixed(2), -7, 4.8, viz.colors.text, 11, 'left');

                viz.drawDraggables();
            }

            draw();
            return viz;
        }
    },

    {
        id: 'ch05-extra-viz-2',
        title: 'Free vs Torsion Decomposition',
        description: 'Explore the structure of a finitely generated module over Z by seeing its decomposition into free and torsion parts.',
        setup: function(container, controls) {
            const viz = new VizEngine(container, {width: 700, height: 420, scale: 1, originX: 0, originY: 0});
            const ctx = viz.ctx;

            let freeRank = 2;
            let torsionParts = [4, 6];

            VizEngine.createSlider(controls, 'Free rank', 0, 4, freeRank, 1, (v) => {
                freeRank = Math.floor(v);
                draw();
            });

            VizEngine.createButton(controls, 'Add Torsion Z/4Z', () => { torsionParts.push(4); draw(); });
            VizEngine.createButton(controls, 'Add Torsion Z/6Z', () => { torsionParts.push(6); draw(); });
            VizEngine.createButton(controls, 'Remove Last', () => { if (torsionParts.length > 0) { torsionParts.pop(); draw(); } });

            function text(str, x, y, color, size, align, baseline) {
                ctx.fillStyle = color; ctx.font = (size || 14) + 'px -apple-system,sans-serif';
                ctx.textAlign = align || 'center'; ctx.textBaseline = baseline || 'middle';
                ctx.fillText(str, x, y);
            }

            function draw() {
                viz.clear();
                const W = viz.width, H = viz.height;
                const parts = [];
                if (freeRank > 0) parts.push({type:'free', rank: freeRank});
                for (const n of torsionParts) parts.push({type:'torsion', n: n});
                if (parts.length === 0) { text('Trivial module {0}', W/2, H/2, viz.colors.text, 18); return; }

                // Title
                text('Module Decomposition', W/2, 30, viz.colors.white, 18);

                // Layout: horizontal, evenly spaced
                const totalParts = parts.length;
                const spacing = Math.min(160, (W - 60) / totalParts);
                const startX = W/2 - (totalParts - 1) * spacing / 2;

                // Formula bar at top
                let formula = '';
                if (freeRank > 0) formula = 'ℤ' + (freeRank > 1 ? '^' + freeRank : '');
                for (const n of torsionParts) {
                    if (formula) formula += ' ⊕ ';
                    formula += 'ℤ/' + n + 'ℤ';
                }
                text('M ≅ ' + formula, W/2, 60, viz.colors.teal, 15);

                const centerY = H/2 + 20;
                const compRadius = 50;

                for (let i = 0; i < parts.length; i++) {
                    const cx = startX + i * spacing;
                    const p = parts[i];

                    if (p.type === 'free') {
                        // Free part: vertical lattice lines
                        text('ℤ' + (p.rank > 1 ? '^' + p.rank : ''), cx, centerY - compRadius - 20, viz.colors.blue, 15);
                        const cols = Math.min(p.rank, 4);
                        const colSpacing = 20;
                        for (let c = 0; c < cols; c++) {
                            const lx = cx - (cols - 1) * colSpacing / 2 + c * colSpacing;
                            // Vertical arrow
                            ctx.strokeStyle = viz.colors.blue; ctx.lineWidth = 2;
                            ctx.beginPath(); ctx.moveTo(lx, centerY - compRadius + 5); ctx.lineTo(lx, centerY + compRadius - 5); ctx.stroke();
                            // Dots
                            for (let d = -3; d <= 3; d++) {
                                ctx.fillStyle = viz.colors.blue + '99';
                                ctx.beginPath(); ctx.arc(lx, centerY + d * 14, 3, 0, Math.PI * 2); ctx.fill();
                            }
                            // Arrowheads
                            ctx.fillStyle = viz.colors.blue;
                            ctx.beginPath(); ctx.moveTo(lx, centerY - compRadius + 2); ctx.lineTo(lx - 4, centerY - compRadius + 10); ctx.lineTo(lx + 4, centerY - compRadius + 10); ctx.closePath(); ctx.fill();
                            ctx.beginPath(); ctx.moveTo(lx, centerY + compRadius - 2); ctx.lineTo(lx - 4, centerY + compRadius - 10); ctx.lineTo(lx + 4, centerY + compRadius - 10); ctx.closePath(); ctx.fill();
                        }
                        text('∞ elements', cx, centerY + compRadius + 18, viz.colors.text, 11);
                    } else {
                        // Torsion part: circle with n points
                        const n = p.n;
                        text('ℤ/' + n + 'ℤ', cx, centerY - compRadius - 20, viz.colors.orange, 15);
                        // Circle
                        ctx.strokeStyle = viz.colors.orange + '66'; ctx.lineWidth = 1.5;
                        ctx.beginPath(); ctx.arc(cx, centerY, compRadius - 5, 0, Math.PI * 2); ctx.stroke();
                        // Points
                        for (let j = 0; j < n; j++) {
                            const angle = (j / n) * Math.PI * 2 - Math.PI / 2;
                            const px = cx + (compRadius - 5) * Math.cos(angle);
                            const py = centerY + (compRadius - 5) * Math.sin(angle);
                            ctx.fillStyle = viz.colors.orange;
                            ctx.beginPath(); ctx.arc(px, py, 4, 0, Math.PI * 2); ctx.fill();
                        }
                        text(n + ' elements', cx, centerY + compRadius + 18, viz.colors.text, 11);
                    }

                    // ⊕ between parts
                    if (i < parts.length - 1) {
                        text('⊕', cx + spacing / 2, centerY, viz.colors.white, 22);
                    }
                }
            }

            draw();
            return viz;
        }
    }
];

// === Noetherian Modules Visualizations ===
window.EXTRA_VIZ['ch05']['ch05-sec02'] = [
    {
        id: 'ch05-extra-viz-3',
        title: 'Ascending Chain Condition Step-Through',
        description: 'Interact with an ascending chain of submodules. Add elements to see when the chain stabilizes.',
        setup: function(container, controls) {
            const viz = new VizEngine(container, {width: 560, height: 420, scale: 1});

            // Chain of ideals in Z: (n₁) ⊆ (n₂) ⊆ (n₃) ⊆ ...
            // where n₁ | n₂ | n₃ | ...
            let chain = [12];
            let stabilized = false;

            VizEngine.createButton(controls, 'Extend: ÷2', () => {
                if (!stabilized && chain[chain.length - 1] % 2 === 0) {
                    chain.push(chain[chain.length - 1] / 2);
                    checkStabilization();
                    draw();
                }
            });

            VizEngine.createButton(controls, 'Extend: ÷3', () => {
                if (!stabilized && chain[chain.length - 1] % 3 === 0) {
                    chain.push(chain[chain.length - 1] / 3);
                    checkStabilization();
                    draw();
                }
            });

            VizEngine.createButton(controls, 'Reset', () => {
                chain = [12];
                stabilized = false;
                draw();
            });

            function checkStabilization() {
                const last = chain[chain.length - 1];
                if (last === 1 || (last > 1 && isPrime(last))) {
                    stabilized = true;
                }
            }

            function isPrime(n) {
                if (n < 2) return false;
                for (let i = 2; i <= Math.sqrt(n); i++) {
                    if (n % i === 0) return false;
                }
                return true;
            }

            function draw() {
                viz.clear();

                const ctx = viz.ctx;
                const centerX = viz.width / 2;
                let y = 40;

                // Title
                ctx.fillStyle = viz.colors.white;
                ctx.font = 'bold 16px -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Ascending Chain in ℤ: Ideals (nᵢ) where nᵢ | nᵢ₊₁', centerX, y);
                y += 40;

                // Draw chain
                for (let i = 0; i < chain.length; i++) {
                    const n = chain[i];
                    const ideal = '(' + n + ')';

                    // Box for ideal
                    const boxWidth = 80;
                    const boxHeight = 40;
                    const boxX = centerX - boxWidth / 2;
                    const boxY = y;

                    // Fill color based on position
                    const hue = (i / Math.max(1, chain.length - 1)) * 200 + 180;
                    ctx.fillStyle = stabilized && i === chain.length - 1 ? viz.colors.green + '33' : 'hsl(' + hue + ', 50%, 30%)';
                    ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                    ctx.strokeStyle = stabilized && i === chain.length - 1 ? viz.colors.green : viz.colors.blue;
                    ctx.lineWidth = stabilized && i === chain.length - 1 ? 3 : 2;
                    ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

                    // Text
                    ctx.fillStyle = viz.colors.white;
                    ctx.font = '18px -apple-system, sans-serif';
                    ctx.fillText(ideal, centerX, boxY + boxHeight / 2 + 6);

                    // Index
                    ctx.fillStyle = viz.colors.text;
                    ctx.font = '12px -apple-system, sans-serif';
                    ctx.fillText('M' + i, boxX - 25, boxY + boxHeight / 2 + 4);

                    y += boxHeight + 10;

                    // Draw inclusion arrow
                    if (i < chain.length - 1) {
                        ctx.strokeStyle = viz.colors.teal;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(centerX, y);
                        ctx.lineTo(centerX, y + 10);
                        ctx.stroke();
                        // Arrowhead
                        ctx.fillStyle = viz.colors.teal;
                        ctx.beginPath();
                        ctx.moveTo(centerX, y + 10);
                        ctx.lineTo(centerX - 4, y + 5);
                        ctx.lineTo(centerX + 4, y + 5);
                        ctx.closePath();
                        ctx.fill();

                        ctx.fillStyle = viz.colors.text;
                        ctx.font = '14px -apple-system, sans-serif';
                        ctx.fillText('⊆', centerX + 25, y + 5);
                        y += 10;
                    }
                }

                // Status message
                y += 20;
                ctx.fillStyle = stabilized ? viz.colors.green : viz.colors.yellow;
                ctx.font = 'bold 14px -apple-system, sans-serif';
                if (stabilized) {
                    ctx.fillText('Chain stabilized! (reached prime or 1)', centerX, y);
                    ctx.fillStyle = viz.colors.text;
                    ctx.font = '12px -apple-system, sans-serif';
                    ctx.fillText('All subsequent ideals equal (' + chain[chain.length - 1] + ')', centerX, y + 20);
                } else {
                    ctx.fillText('Chain can continue (ACC not yet triggered)', centerX, y);
                    ctx.fillStyle = viz.colors.text;
                    ctx.font = '12px -apple-system, sans-serif';
                    ctx.fillText('Click buttons to divide by 2 or 3', centerX, y + 20);
                }
            }

            draw();
            return viz;
        }
    },

    {
        id: 'ch05-extra-viz-4',
        title: 'Noetherian Property Checker',
        description: 'Check if a finitely generated module structure satisfies the Noetherian property. Visualize submodule chains.',
        setup: function(container, controls) {
            const viz = new VizEngine(container, {width: 560, height: 400, scale: 1});

            let ringType = 'Z'; // Z (Noetherian) or Q[x,y,...] (non-Noetherian example)
            let generatorCount = 2;

            VizEngine.createButton(controls, 'Ring: ℤ', () => {
                ringType = 'Z';
                draw();
            });

            VizEngine.createButton(controls, 'Ring: ℤ[x]', () => {
                ringType = 'Z[x]';
                draw();
            });

            VizEngine.createSlider(controls, 'Generators', 1, 4, generatorCount, 1, (v) => {
                generatorCount = Math.floor(v);
                draw();
            });

            function draw() {
                viz.clear();

                const ctx = viz.ctx;
                const centerX = viz.width / 2;
                let y = 40;

                // Title
                ctx.fillStyle = viz.colors.white;
                ctx.font = 'bold 18px -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Noetherian Property Analysis', centerX, y);
                y += 50;

                // Ring info
                ctx.font = '16px -apple-system, sans-serif';
                ctx.fillStyle = viz.colors.blue;
                ctx.fillText('Ring R: ' + ringType, centerX, y);
                y += 30;

                // Module info
                ctx.fillStyle = viz.colors.teal;
                const moduleName = 'M = R^' + generatorCount;
                ctx.fillText('Module: ' + moduleName, centerX, y);
                y += 40;

                // Check Noetherian
                const isNoetherian = (ringType === 'Z' || ringType === 'Z[x]');

                // Result box
                const boxWidth = 400;
                const boxHeight = 180;
                const boxX = centerX - boxWidth / 2;
                const boxY = y;

                ctx.fillStyle = isNoetherian ? viz.colors.green + '22' : viz.colors.red + '22';
                ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                ctx.strokeStyle = isNoetherian ? viz.colors.green : viz.colors.red;
                ctx.lineWidth = 2;
                ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

                y += 30;

                // Result text
                ctx.fillStyle = isNoetherian ? viz.colors.green : viz.colors.red;
                ctx.font = 'bold 16px -apple-system, sans-serif';
                ctx.fillText(isNoetherian ? 'NOETHERIAN ✓' : 'NOT NOETHERIAN ✗', centerX, y);
                y += 30;

                ctx.fillStyle = viz.colors.white;
                ctx.font = '14px -apple-system, sans-serif';

                if (isNoetherian) {
                    ctx.fillText('All submodules are finitely generated', centerX, y);
                    y += 25;
                    ctx.fillText('Every ascending chain stabilizes', centerX, y);
                    y += 25;

                    if (ringType === 'Z') {
                        ctx.fillStyle = viz.colors.text;
                        ctx.font = '12px -apple-system, sans-serif';
                        ctx.fillText('ℤ is Noetherian (PID, all ideals principal)', centerX, y);
                    } else if (ringType === 'Z[x]') {
                        ctx.fillStyle = viz.colors.text;
                        ctx.font = '12px -apple-system, sans-serif';
                        ctx.fillText('ℤ[x] is Noetherian (Hilbert Basis Theorem)', centerX, y);
                    }
                } else {
                    ctx.fillText('Some submodules not finitely generated', centerX, y);
                    y += 25;
                    ctx.fillText('Ascending chains need not stabilize', centerX, y);
                    y += 25;

                    ctx.fillStyle = viz.colors.text;
                    ctx.font = '12px -apple-system, sans-serif';
                    ctx.fillText('Example: polynomial rings with infinitely many variables', centerX, y);
                }

                y += 35;

                // Example chain
                ctx.fillStyle = viz.colors.text;
                ctx.font = 'bold 12px -apple-system, sans-serif';
                ctx.fillText('Example ascending chain:', centerX, y);
                y += 20;

                ctx.font = '11px -apple-system, sans-serif';
                if (ringType === 'Z') {
                    ctx.fillText('(12) ⊆ (6) ⊆ (3) ⊆ (3) ⊆ (3) ⊆ ...  (stabilizes at (3))', centerX, y);
                } else if (ringType === 'Z[x]') {
                    ctx.fillText('(x²) ⊆ (x) ⊆ (x) ⊆ (x) ⊆ ...  (stabilizes at (x))', centerX, y);
                }
            }

            draw();
            return viz;
        }
    },

    {
        id: 'ch05-extra-viz-5',
        title: 'Submodule Chain Stabilization Animation',
        description: 'Watch an ascending chain of submodules grow and eventually stabilize, illustrating the ACC.',
        setup: function(container, controls) {
            const viz = new VizEngine(container, {width: 560, height: 400, scale: 1});

            let time = 0;
            let paused = false;
            let speed = 1;

            VizEngine.createButton(controls, 'Play/Pause', () => {
                paused = !paused;
            });

            VizEngine.createButton(controls, 'Reset', () => {
                time = 0;
            });

            VizEngine.createSlider(controls, 'Speed', 0.1, 3, speed, 0.1, (v) => {
                speed = v;
            });

            function getChainLength(t) {
                // Chain grows then stabilizes
                if (t < 5) return Math.floor(t) + 1;
                return 5; // stabilizes at length 5
            }

            function draw() {
                viz.clear();

                if (!paused) {
                    time += 0.016 * speed; // ~60fps
                }

                const ctx = viz.ctx;
                const centerX = viz.width / 2;
                let y = 30;

                // Title
                ctx.fillStyle = viz.colors.white;
                ctx.font = 'bold 16px -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Ascending Chain Stabilization', centerX, y);
                y += 35;

                const chainLength = getChainLength(time);
                const stabilized = time >= 5;

                // Time display
                ctx.fillStyle = viz.colors.text;
                ctx.font = '12px -apple-system, sans-serif';
                ctx.fillText('Time: ' + time.toFixed(1) + 's', centerX, y);
                y += 30;

                // Draw chain elements
                const spacing = 60;
                const startY = y;

                for (let i = 0; i < chainLength; i++) {
                    const elemY = startY + i * spacing;
                    const size = 40 + i * 8; // Growing sets
                    const boxX = centerX - size / 2;
                    const boxY = elemY;

                    // Pulsing effect when growing
                    const isNew = !stabilized && i === chainLength - 1 && time % 1 < 0.5;
                    const pulse = isNew ? 1 + Math.sin(time * 10) * 0.1 : 1;

                    ctx.save();
                    ctx.translate(centerX, elemY + 20);
                    ctx.scale(pulse, pulse);
                    ctx.translate(-centerX, -(elemY + 20));

                    // Box
                    ctx.fillStyle = stabilized && i === chainLength - 1 ? viz.colors.green + '33' : viz.colors.blue + '22';
                    ctx.fillRect(boxX, boxY, size, 40);
                    ctx.strokeStyle = stabilized && i === chainLength - 1 ? viz.colors.green : viz.colors.blue;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(boxX, boxY, size, 40);

                    // Label
                    ctx.fillStyle = viz.colors.white;
                    ctx.font = '14px -apple-system, sans-serif';
                    ctx.fillText('M' + i, centerX, boxY + 25);

                    ctx.restore();

                    // Inclusion arrow
                    if (i < chainLength - 1) {
                        const arrowY = boxY + 45;
                        ctx.strokeStyle = viz.colors.teal + '88';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(centerX, arrowY);
                        ctx.lineTo(centerX, arrowY + 10);
                        ctx.stroke();

                        ctx.fillStyle = viz.colors.teal + '88';
                        ctx.beginPath();
                        ctx.moveTo(centerX, arrowY + 10);
                        ctx.lineTo(centerX - 3, arrowY + 6);
                        ctx.lineTo(centerX + 3, arrowY + 6);
                        ctx.closePath();
                        ctx.fill();

                        ctx.fillStyle = viz.colors.text;
                        ctx.font = '12px -apple-system, sans-serif';
                        ctx.fillText('⊆', centerX + 20, arrowY + 5);
                    }
                }

                // Status message
                const statusY = startY + chainLength * spacing + 20;
                ctx.fillStyle = stabilized ? viz.colors.green : viz.colors.yellow;
                ctx.font = 'bold 14px -apple-system, sans-serif';
                if (stabilized) {
                    ctx.fillText('✓ Chain has STABILIZED', centerX, statusY);
                    ctx.fillStyle = viz.colors.text;
                    ctx.font = '12px -apple-system, sans-serif';
                    ctx.fillText('M₄ = M₅ = M₆ = ... (ACC satisfied)', centerX, statusY + 20);
                } else {
                    ctx.fillText('Chain still growing...', centerX, statusY);
                }
            }

            viz.animate(draw);
            return viz;
        }
    }
];

// === Hilbert Basis Theorem Visualization ===
window.EXTRA_VIZ['ch05']['ch05-sec03'] = [
    {
        id: 'ch05-extra-viz-6',
        title: 'Hilbert Basis Theorem Illustration',
        description: 'Understand how the Hilbert Basis Theorem extends the Noetherian property from a ring to its polynomial ring.',
        setup: function(container, controls) {
            const viz = new VizEngine(container, {width: 560, height: 450, scale: 1});

            let level = 0; // 0: R, 1: R[x], 2: R[x,y], 3: R[x,y,z]

            VizEngine.createButton(controls, 'Start: Ring R', () => {
                level = 0;
                draw();
            });

            VizEngine.createButton(controls, 'Add variable x → R[x]', () => {
                if (level < 3) {
                    level++;
                    draw();
                }
            });

            VizEngine.createButton(controls, 'Reset', () => {
                level = 0;
                draw();
            });

            function getRingName(lvl) {
                if (lvl === 0) return 'R (Noetherian)';
                if (lvl === 1) return 'R[x]';
                if (lvl === 2) return 'R[x,y]';
                if (lvl === 3) return 'R[x,y,z]';
                return 'R[x₁,...,xₙ]';
            }

            function draw() {
                viz.clear();

                const ctx = viz.ctx;
                const centerX = viz.width / 2;
                let y = 30;

                // Title
                ctx.fillStyle = viz.colors.white;
                ctx.font = 'bold 18px -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Hilbert Basis Theorem', centerX, y);
                y += 30;

                ctx.fillStyle = viz.colors.text;
                ctx.font = '13px -apple-system, sans-serif';
                ctx.fillText('If R is Noetherian, then R[x], R[x,y], ... are all Noetherian', centerX, y);
                y += 50;

                // Draw tower of rings
                const layers = [];
                for (let i = 0; i <= level; i++) {
                    layers.push({
                        name: getRingName(i),
                        active: i === level
                    });
                }

                const boxHeight = 60;
                const boxWidth = 200;
                const layerSpacing = 80;

                for (let i = 0; i < layers.length; i++) {
                    const layer = layers[i];
                    const layerY = y + i * layerSpacing;
                    const boxX = centerX - boxWidth / 2;

                    // Box
                    const isActive = layer.active;
                    ctx.fillStyle = isActive ? viz.colors.blue + '44' : viz.colors.blue + '11';
                    ctx.fillRect(boxX, layerY, boxWidth, boxHeight);
                    ctx.strokeStyle = isActive ? viz.colors.blue : viz.colors.blue + '66';
                    ctx.lineWidth = isActive ? 3 : 1.5;
                    ctx.strokeRect(boxX, layerY, boxWidth, boxHeight);

                    // Ring name
                    ctx.fillStyle = viz.colors.white;
                    ctx.font = 'bold 16px -apple-system, sans-serif';
                    ctx.fillText(layer.name, centerX, layerY + boxHeight / 2 - 5);

                    // Status
                    ctx.fillStyle = viz.colors.green;
                    ctx.font = '12px -apple-system, sans-serif';
                    ctx.fillText('Noetherian ✓', centerX, layerY + boxHeight / 2 + 13);

                    // Arrow to next level
                    if (i < layers.length - 1) {
                        const arrowY = layerY + boxHeight;
                        ctx.strokeStyle = viz.colors.teal;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(centerX, arrowY);
                        ctx.lineTo(centerX, arrowY + 15);
                        ctx.stroke();

                        // Arrowhead
                        ctx.fillStyle = viz.colors.teal;
                        ctx.beginPath();
                        ctx.moveTo(centerX, arrowY + 15);
                        ctx.lineTo(centerX - 4, arrowY + 10);
                        ctx.lineTo(centerX + 4, arrowY + 10);
                        ctx.closePath();
                        ctx.fill();

                        // Label
                        ctx.fillStyle = viz.colors.text;
                        ctx.font = '11px -apple-system, sans-serif';
                        ctx.fillText('add var', centerX + 40, arrowY + 8);
                    }
                }

                // Explanation box
                const explainY = y + layers.length * layerSpacing + 20;
                const explainBoxX = 40;
                const explainBoxWidth = viz.width - 80;
                const explainBoxHeight = 110;

                ctx.fillStyle = viz.colors.purple + '11';
                ctx.fillRect(explainBoxX, explainY, explainBoxWidth, explainBoxHeight);
                ctx.strokeStyle = viz.colors.purple + '66';
                ctx.lineWidth = 1;
                ctx.strokeRect(explainBoxX, explainY, explainBoxWidth, explainBoxHeight);

                let textY = explainY + 20;
                ctx.fillStyle = viz.colors.purple;
                ctx.font = 'bold 13px -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Key Insight', centerX, textY);
                textY += 22;

                ctx.fillStyle = viz.colors.white;
                ctx.font = '12px -apple-system, sans-serif';
                ctx.fillText('Every ideal I ⊆ R[x₁,...,xₙ] is finitely generated', centerX, textY);
                textY += 18;
                ctx.fillText('Proof: Induction using leading coefficient ideals', centerX, textY);
                textY += 18;
                ctx.fillStyle = viz.colors.text;
                ctx.font = '11px -apple-system, sans-serif';
                ctx.fillText('This generalizes to finitely many variables', centerX, textY);
            }

            draw();
            return viz;
        }
    },

    {
        id: 'ch05-extra-viz-7',
        title: 'Ideal Generation in Polynomial Rings',
        description: 'Visualize how ideals in R[x] are finitely generated using the Hilbert Basis Theorem construction.',
        setup: function(container, controls) {
            const viz = new VizEngine(container, {width: 560, height: 400, scale: 1});

            let showConstruction = false;
            let step = 0;

            VizEngine.createButton(controls, 'Show Construction', () => {
                showConstruction = !showConstruction;
                draw();
            });

            VizEngine.createButton(controls, 'Next Step', () => {
                if (showConstruction && step < 4) {
                    step++;
                    draw();
                }
            });

            VizEngine.createButton(controls, 'Reset', () => {
                step = 0;
                showConstruction = false;
                draw();
            });

            function draw() {
                viz.clear();

                const ctx = viz.ctx;
                const centerX = viz.width / 2;
                let y = 30;

                // Title
                ctx.fillStyle = viz.colors.white;
                ctx.font = 'bold 16px -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Ideal in ℤ[x]: Construction via HBT', centerX, y);
                y += 40;

                // Example ideal
                ctx.fillStyle = viz.colors.blue;
                ctx.font = '14px -apple-system, sans-serif';
                ctx.fillText('I = ⟨2x² + 3x + 1, x³ + 2x⟩', centerX, y);
                y += 35;

                if (!showConstruction) {
                    ctx.fillStyle = viz.colors.text;
                    ctx.font = '12px -apple-system, sans-serif';
                    ctx.fillText('Click "Show Construction" to see how HBT proves I is finitely generated', centerX, y);
                    return;
                }

                // Construction steps
                const steps = [
                    {
                        title: 'Step 0: Start with ideal I',
                        content: 'I is generated by two polynomials',
                        color: viz.colors.white
                    },
                    {
                        title: 'Step 1: Leading coefficient ideal',
                        content: 'L = {leading coeff of p : p ∈ I} = ⟨2, 1⟩ = ⟨1⟩ = ℤ',
                        color: viz.colors.orange
                    },
                    {
                        title: 'Step 2: L is finitely generated',
                        content: 'Since ℤ is Noetherian, L = ⟨1⟩',
                        color: viz.colors.green
                    },
                    {
                        title: 'Step 3: Find polynomials with these coeffs',
                        content: 'Can generate all polynomials in I',
                        color: viz.colors.teal
                    },
                    {
                        title: 'Step 4: Conclusion',
                        content: 'I is finitely generated by original generators',
                        color: viz.colors.purple
                    }
                ];

                for (let i = 0; i <= Math.min(step, steps.length - 1); i++) {
                    const s = steps[i];
                    const stepY = y;

                    // Step box
                    const boxWidth = 480;
                    const boxHeight = 60;
                    const boxX = centerX - boxWidth / 2;

                    ctx.fillStyle = s.color + '22';
                    ctx.fillRect(boxX, stepY, boxWidth, boxHeight);
                    ctx.strokeStyle = s.color;
                    ctx.lineWidth = i === step ? 2.5 : 1;
                    ctx.strokeRect(boxX, stepY, boxWidth, boxHeight);

                    // Title
                    ctx.fillStyle = s.color;
                    ctx.font = 'bold 13px -apple-system, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(s.title, centerX, stepY + 20);

                    // Content
                    ctx.fillStyle = viz.colors.white;
                    ctx.font = '11px -apple-system, sans-serif';
                    ctx.fillText(s.content, centerX, stepY + 42);

                    y += boxHeight + 15;
                }

                // Summary
                if (step === steps.length - 1) {
                    y += 10;
                    ctx.fillStyle = viz.colors.green;
                    ctx.font = 'bold 14px -apple-system, sans-serif';
                    ctx.fillText('✓ Ideal I is finitely generated!', centerX, y);
                }
            }

            draw();
            return viz;
        }
    }
];
