window.CHAPTERS = window.CHAPTERS || [];
window.CHAPTERS.push({
    id: 'ch18',
    number: 18,
    title: 'An Introduction to Algebras',
    subtitle: 'Algebras over fields, ideals, division algebras, and classical structure theorems',
    sections: [
        {
            id: 'ch18-sec01',
            title: 'Algebras and Subalgebras',
            content: `
                <h2>Algebras and Subalgebras</h2>

                <p>An algebra combines the structure of a vector space with a multiplication operation, creating a rich mathematical object that unifies linear algebra with ring theory. Algebras are fundamental in representation theory, quantum mechanics, and modern geometry.</p>

                <div class="env-block definition">
                    <div class="env-title">Definition 18.1 (Algebra over a Field)</div>
                    <div class="env-body">
                        <p>Let \\(F\\) be a field. An <strong>algebra</strong> (or \\(F\\)-algebra) \\(A\\) is a vector space over \\(F\\) equipped with a bilinear multiplication operation \\(A \\times A \\to A\\), denoted \\((a, b) \\mapsto ab\\), satisfying:</p>
                        <ol>
                            <li><strong>Bilinearity</strong>:
                                \\[\\begin{align*}
                                (a + b)c &= ac + bc \\\\
                                a(b + c) &= ab + ac \\\\
                                (\\alpha a)b &= a(\\alpha b) = \\alpha(ab)
                                \\end{align*}\\]
                                for all \\(a, b, c \\in A\\) and \\(\\alpha \\in F\\).
                            </li>
                        </ol>
                        <p>If the multiplication is associative, \\(A\\) is an <strong>associative algebra</strong>. If there exists \\(1 \\in A\\) with \\(1a = a1 = a\\) for all \\(a \\in A\\), then \\(A\\) is a <strong>unital algebra</strong> (or algebra with identity).</p>
                    </div>
                </div>

                <div class="env-block intuition">
                    <div class="env-title">Intuition</div>
                    <div class="env-body">
                        <p>Think of an algebra as a vector space where vectors can be multiplied together to produce new vectors, not just scalars. The bilinearity condition ensures this multiplication is compatible with the vector space structure. Examples range from familiar objects like matrix algebras to exotic structures like quaternions and Clifford algebras.</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 18.1 (Fundamental Examples)</div>
                    <div class="env-body">
                        <p><strong>(a) Matrix Algebras</strong>: The space \\(M_n(F)\\) of \\(n \\times n\\) matrices over \\(F\\) is an associative unital algebra under matrix multiplication. Its dimension as an \\(F\\)-vector space is \\(n^2\\).</p>

                        <p><strong>(b) Polynomial Algebras</strong>: The polynomial ring \\(F[x]\\) is an infinite-dimensional commutative unital algebra over \\(F\\).</p>

                        <p><strong>(c) Function Algebras</strong>: If \\(X\\) is any set, the space \\(F^X\\) of all functions \\(X \\to F\\) is a commutative algebra under pointwise multiplication: \\((fg)(x) = f(x)g(x)\\).</p>

                        <p><strong>(d) Group Algebras</strong>: Given a finite group \\(G\\), the <strong>group algebra</strong> \\(F[G]\\) consists of formal linear combinations \\(\\sum_{g \\in G} \\alpha_g g\\) with \\(\\alpha_g \\in F\\). Multiplication extends the group operation linearly:
                        \\[\\left(\\sum \\alpha_g g\\right)\\left(\\sum \\beta_h h\\right) = \\sum_{g,h} \\alpha_g \\beta_h (gh)\\]
                        This algebra has dimension \\(|G|\\) over \\(F\\).</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="mult-table-viz"></div>

                <div class="env-block definition">
                    <div class="env-title">Definition 18.2 (Subalgebra)</div>
                    <div class="env-body">
                        <p>A <strong>subalgebra</strong> \\(B\\) of an algebra \\(A\\) is a subspace of \\(A\\) that is closed under multiplication. If \\(A\\) has an identity \\(1\\), we typically require \\(1 \\in B\\).</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 18.1 (Subalgebra Generated by a Set)</div>
                    <div class="env-body">
                        <p>If \\(S \\subseteq A\\) is any subset of an algebra \\(A\\), the subalgebra \\(\\langle S \\rangle_{\\text{alg}}\\) generated by \\(S\\) is the subspace spanned by all finite products of elements of \\(S\\):
                        \\[\\langle S \\rangle_{\\text{alg}} = \\operatorname{span}_F\\{s_1 s_2 \\cdots s_k : s_i \\in S, k \\geq 1\\}\\]
                        </p>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 18.3 (Center of an Algebra)</div>
                    <div class="env-body">
                        <p>The <strong>center</strong> of an algebra \\(A\\) is
                        \\[Z(A) = \\{z \\in A : za = az \\text{ for all } a \\in A\\}\\]
                        The center is always a commutative subalgebra of \\(A\\).</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 18.2 (Center of Matrix Algebra)</div>
                    <div class="env-body">
                        <p>For \\(n \\geq 2\\), the center of \\(M_n(F)\\) consists of scalar matrices:
                        \\[Z(M_n(F)) = \\{\\alpha I : \\alpha \\in F\\} \\cong F\\]
                        This is because any matrix commuting with all matrices must commute with the elementary matrices \\(E_{ij}\\), which forces it to be scalar.</p>
                    </div>
                </div>

                <div class="env-block remark">
                    <div class="env-title">Remark</div>
                    <div class="env-body">
                        <p>An algebra \\(A\\) is <strong>central</strong> if \\(Z(A) = F \\cdot 1\\). The matrix algebra \\(M_n(F)\\) for \\(n \\geq 2\\) is central, making it a fundamental example in the theory of simple algebras.</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'mult-table-viz',
                    title: 'Interactive: Multiplication Table of a Finite Algebra',
                    description: 'Explore the multiplication structure of a small group algebra. See how different group structures lead to different algebra structures.',
                    setup: function(container, controls) {
                        const viz = new VizEngine(container, {width: 560, height: 480, scale: 1});

                        const groups = {
                            'Z3': {
                                name: 'ℤ₃ (cyclic group of order 3)',
                                elements: ['e', 'a', 'a²'],
                                mult: [[0,1,2], [1,2,0], [2,0,1]]
                            },
                            'Klein': {
                                name: 'V₄ (Klein four-group)',
                                elements: ['e', 'a', 'b', 'ab'],
                                mult: [[0,1,2,3], [1,0,3,2], [2,3,0,1], [3,2,1,0]]
                            },
                            'S3': {
                                name: 'S₃ (symmetric group on 3 elements)',
                                elements: ['e', 'r', 'r²', 's', 'sr', 'sr²'],
                                mult: [
                                    [0,1,2,3,4,5],
                                    [1,2,0,4,5,3],
                                    [2,0,1,5,3,4],
                                    [3,5,4,0,2,1],
                                    [4,3,5,1,0,2],
                                    [5,4,3,2,1,0]
                                ]
                            }
                        };

                        let currentGroup = 'Z3';

                        const groupSelect = document.createElement('select');
                        groupSelect.style.marginBottom = '15px';
                        groupSelect.style.padding = '5px';
                        groupSelect.style.fontSize = '14px';
                        for (const key in groups) {
                            const opt = document.createElement('option');
                            opt.value = key;
                            opt.textContent = groups[key].name;
                            groupSelect.appendChild(opt);
                        }
                        groupSelect.addEventListener('change', (e) => {
                            currentGroup = e.target.value;
                            draw();
                        });
                        controls.appendChild(groupSelect);

                        const infoDiv = document.createElement('div');
                        infoDiv.style.marginTop = '10px';
                        infoDiv.style.fontFamily = 'monospace';
                        infoDiv.style.fontSize = '12px';
                        controls.appendChild(infoDiv);

                        function draw() {
                            viz.clear();
                            const g = groups[currentGroup];
                            const n = g.elements.length;
                            const cellSize = Math.min(60, 480 / (n + 1));
                            const tableWidth = cellSize * (n + 1);
                            const tableHeight = cellSize * (n + 1);
                            const offsetX = (560 - tableWidth) / 2;
                            const offsetY = 30;

                            viz.ctx.save();
                            viz.ctx.translate(offsetX, offsetY);

                            // Draw header
                            viz.ctx.fillStyle = viz.colors.text;
                            viz.ctx.font = 'bold 14px monospace';
                            viz.ctx.textAlign = 'center';
                            viz.ctx.textBaseline = 'middle';
                            viz.ctx.fillText('·', cellSize / 2, cellSize / 2);

                            // Column headers
                            for (let i = 0; i < n; i++) {
                                viz.ctx.fillText(g.elements[i], (i + 1) * cellSize + cellSize / 2, cellSize / 2);
                            }

                            // Row headers and table
                            for (let i = 0; i < n; i++) {
                                viz.ctx.fillText(g.elements[i], cellSize / 2, (i + 1) * cellSize + cellSize / 2);

                                for (let j = 0; j < n; j++) {
                                    const result = g.mult[i][j];

                                    // Cell background
                                    const hue = (result * 360 / n) % 360;
                                    viz.ctx.fillStyle = `hsl(${hue}, 60%, 30%)`;
                                    viz.ctx.fillRect((j + 1) * cellSize + 2, (i + 1) * cellSize + 2,
                                                     cellSize - 4, cellSize - 4);

                                    // Cell border
                                    viz.ctx.strokeStyle = viz.colors.text + '44';
                                    viz.ctx.strokeRect((j + 1) * cellSize, (i + 1) * cellSize, cellSize, cellSize);

                                    // Product result
                                    viz.ctx.fillStyle = viz.colors.white;
                                    viz.ctx.font = '12px monospace';
                                    viz.ctx.fillText(g.elements[result],
                                                    (j + 1) * cellSize + cellSize / 2,
                                                    (i + 1) * cellSize + cellSize / 2);
                                }
                            }

                            // Border for header row and column
                            viz.ctx.strokeStyle = viz.colors.white;
                            viz.ctx.lineWidth = 2;
                            viz.ctx.strokeRect(0, 0, (n + 1) * cellSize, cellSize);
                            viz.ctx.strokeRect(0, 0, cellSize, (n + 1) * cellSize);

                            viz.ctx.restore();

                            // Check if commutative
                            let isCommutative = true;
                            for (let i = 0; i < n && isCommutative; i++) {
                                for (let j = 0; j < n; j++) {
                                    if (g.mult[i][j] !== g.mult[j][i]) {
                                        isCommutative = false;
                                        break;
                                    }
                                }
                            }

                            infoDiv.innerHTML = `<span style="color: ${viz.colors.blue}">Group algebra F[${currentGroup}]</span><br>` +
                                `Dimension: ${n}<br>` +
                                `${isCommutative ? '<span style="color: ' + viz.colors.green + '">Commutative ✓</span>' :
                                                   '<span style="color: ' + viz.colors.orange + '">Non-commutative</span>'}<br>` +
                                `The multiplication table shows xy for row x, column y.`;
                        }

                        draw();
                        return viz;
                    }
                }
            ],
            exercises: [
                {
                    question: 'Show that the center \\(Z(A)\\) of any algebra \\(A\\) is a commutative subalgebra.',
                    hint: 'Show that \\(Z(A)\\) is closed under addition, scalar multiplication, and multiplication. For commutativity, if \\(z_1, z_2 \\in Z(A)\\), does \\(z_1 z_2 = z_2 z_1\\)?',
                    solution: 'Closure under vector operations is clear. For multiplication: if \\(z_1, z_2 \\in Z(A)\\) and \\(a \\in A\\), then \\((z_1 z_2)a = z_1(z_2 a) = z_1(a z_2) = (z_1 a)z_2 = (a z_1)z_2 = a(z_1 z_2)\\), so \\(z_1 z_2 \\in Z(A)\\). For commutativity, since \\(z_1\\) commutes with all elements including \\(z_2\\), we have \\(z_1 z_2 = z_2 z_1\\).'
                },
                {
                    question: 'Prove that for a finite group \\(G\\), the group algebra \\(F[G]\\) has dimension \\(|G|\\) over \\(F\\), and that \\(\\{g : g \\in G\\}\\) forms a basis.',
                    hint: 'Show linear independence: if \\(\\sum \\alpha_g g = 0\\), what must each \\(\\alpha_g\\) be?',
                    solution: 'The set \\(G\\) spans \\(F[G]\\) by definition. For linear independence, suppose \\(\\sum_{g \\in G} \\alpha_g g = 0\\). For each \\(h \\in G\\), the coefficient of \\(h\\) in this sum is \\(\\alpha_h\\), so \\(\\alpha_h = 0\\). Thus \\(G\\) is linearly independent and forms a basis, giving \\(\\dim_F F[G] = |G|\\).'
                },
                {
                    question: 'Let \\(A\\) be the algebra of upper triangular \\(2 \\times 2\\) matrices over \\(F\\). Find \\(\\dim_F A\\), determine whether \\(A\\) is commutative, and describe \\(Z(A)\\).',
                    hint: 'Count the free entries in an upper triangular matrix. Test commutativity with specific examples.',
                    solution: 'An upper triangular \\(2 \\times 2\\) matrix has the form \\(\\begin{pmatrix} a & b \\\\ 0 & c \\end{pmatrix}\\), giving \\(\\dim_F A = 3\\). It is not commutative: \\(\\begin{pmatrix} 1 & 1 \\\\ 0 & 0 \\end{pmatrix}\\begin{pmatrix} 0 & 0 \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}\\) but the reverse product is zero. The center consists of scalar matrices: \\(Z(A) = \\{\\alpha I : \\alpha \\in F\\}\\).'
                }
            ]
        },
        {
            id: 'ch18-sec02',
            title: 'Ideals and Quotient Algebras',
            content: `
                <h2>Ideals and Quotient Algebras</h2>

                <p>Just as normal subgroups enable quotient groups and ideals enable quotient rings, we need a notion of "ideal" in algebras to construct quotient algebras that preserve the algebra structure.</p>

                <div class="env-block definition">
                    <div class="env-title">Definition 18.4 (Ideals in Algebras)</div>
                    <div class="env-body">
                        <p>Let \\(A\\) be an algebra. A subspace \\(I \\subseteq A\\) is a <strong>left ideal</strong> if \\(AI \\subseteq I\\), that is, \\(ai \\in I\\) for all \\(a \\in A\\) and \\(i \\in I\\). Similarly, \\(I\\) is a <strong>right ideal</strong> if \\(IA \\subseteq I\\).</p>

                        <p>A <strong>two-sided ideal</strong> (or simply <strong>ideal</strong>) is a subspace that is both a left and right ideal. We write \\(I \\triangleleft A\\) to denote that \\(I\\) is an ideal of \\(A\\).</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 18.3 (Ideals in Matrix Algebras)</div>
                    <div class="env-body">
                        <p>In \\(M_n(F)\\) for \\(n \\geq 2\\), the only two-sided ideals are \\(\\{0\\}\\) and \\(M_n(F)\\) itself. This makes \\(M_n(F)\\) a <strong>simple algebra</strong>.</p>

                        <p>To see this, suppose \\(I \\triangleleft M_n(F)\\) contains a nonzero matrix \\(A\\). Since \\(A \\neq 0\\), some entry \\(a_{ij} \\neq 0\\). Then \\(E_{ki} A E_{jl} = a_{ij} E_{kl} \\in I\\) (where \\(E_{kl}\\) is the elementary matrix with 1 in position \\((k,l)\\) and 0 elsewhere). Since \\(a_{ij} \\neq 0\\), we have \\(E_{kl} \\in I\\) for all \\(k, l\\). Therefore \\(I = M_n(F)\\).</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="ideal-viz"></div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 18.2 (Quotient Algebra)</div>
                    <div class="env-body">
                        <p>If \\(I \\triangleleft A\\) is a two-sided ideal, then the quotient vector space \\(A/I\\) inherits an algebra structure via
                        \\[(a + I)(b + I) = ab + I\\]
                        This multiplication is well-defined and makes \\(A/I\\) an algebra, called the <strong>quotient algebra</strong>.</p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof</div>
                    <div class="env-body">
                        <p>Well-definedness: Suppose \\(a + I = a' + I\\) and \\(b + I = b' + I\\). Then \\(a' = a + i_1\\) and \\(b' = b + i_2\\) for some \\(i_1, i_2 \\in I\\). We compute:
                        \\[a'b' = (a + i_1)(b + i_2) = ab + ai_2 + i_1 b + i_1 i_2\\]
                        Since \\(I\\) is a two-sided ideal, \\(ai_2, i_1 b, i_1 i_2 \\in I\\), so \\(a'b' - ab \\in I\\), giving \\(a'b' + I = ab + I\\).</p>

                        <p>The algebra axioms for \\(A/I\\) follow from those of \\(A\\) via the quotient map \\(\\pi : A \\to A/I\\).</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 18.5 (Simple Algebra)</div>
                    <div class="env-body">
                        <p>An algebra \\(A\\) is <strong>simple</strong> if its only two-sided ideals are \\(\\{0\\}\\) and \\(A\\), and \\(A^2 \\neq \\{0\\}\\) (i.e., \\(A\\) is not abelian as a ring).</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 18.3 (\\(M_n(F)\\) is Simple)</div>
                    <div class="env-body">
                        <p>For any field \\(F\\) and \\(n \\geq 1\\), the matrix algebra \\(M_n(F)\\) is simple.</p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof</div>
                    <div class="env-body">
                        <p>We showed in Example 18.3 that any nonzero ideal contains all elementary matrices \\(E_{ij}\\), hence equals \\(M_n(F)\\). For \\(n \\geq 1\\), \\(M_n(F)^2 \\neq \\{0\\}\\) since matrix multiplication is nontrivial.</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 18.4 (Quotient by Polynomial Ideal)</div>
                    <div class="env-body">
                        <p>In the polynomial algebra \\(F[x]\\), the ideal \\(\\langle x^2 + 1 \\rangle\\) generated by \\(x^2 + 1\\) gives the quotient algebra
                        \\[F[x]/\\langle x^2 + 1 \\rangle\\]
                        where \\(x^2 = -1\\). When \\(F = \\mathbb{R}\\), this quotient is isomorphic to \\(\\mathbb{C}\\) via \\(x \\mapsto i\\).</p>
                    </div>
                </div>

                <div class="env-block remark">
                    <div class="env-title">Remark (Connection to Ring Theory)</div>
                    <div class="env-body">
                        <p>Every algebra is a ring under its addition and multiplication. The ideal structure of algebras is precisely the ring-theoretic notion, but algebras carry additional vector space structure that makes their representation theory richer.</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'ideal-viz',
                    title: 'Interactive: Ideal Structure Visualization',
                    description: 'Visualize how ideals absorb multiplication from the algebra. See the difference between left ideals, right ideals, and two-sided ideals.',
                    setup: function(container, controls) {
                        const viz = new VizEngine(container, {width: 560, height: 400, scale: 60});

                        let idealType = 'two-sided';

                        const typeSelect = document.createElement('select');
                        typeSelect.style.marginBottom = '10px';
                        typeSelect.style.padding = '5px';
                        const options = [
                            {value: 'two-sided', label: 'Two-sided ideal (AI ⊆ I and IA ⊆ I)'},
                            {value: 'left', label: 'Left ideal only (AI ⊆ I)'},
                            {value: 'right', label: 'Right ideal only (IA ⊆ I)'}
                        ];
                        options.forEach(opt => {
                            const option = document.createElement('option');
                            option.value = opt.value;
                            option.textContent = opt.label;
                            typeSelect.appendChild(option);
                        });
                        typeSelect.addEventListener('change', (e) => {
                            idealType = e.target.value;
                            draw();
                        });
                        controls.appendChild(typeSelect);

                        const infoDiv = document.createElement('div');
                        infoDiv.style.marginTop = '10px';
                        infoDiv.style.fontFamily = 'monospace';
                        infoDiv.style.fontSize = '12px';
                        controls.appendChild(infoDiv);

                        function draw() {
                            viz.clear();

                            // Draw algebra A as large circle
                            viz.drawCircle(0, 0, 4, viz.colors.blue + '22', viz.colors.blue);
                            viz.drawText('A', 3, 3, viz.colors.white, 18, 'center', 'middle');

                            // Draw ideal I as smaller circle
                            viz.drawCircle(-1, 0, 1.5, viz.colors.orange + '33', viz.colors.orange);
                            viz.drawText('I', -1, 0, viz.colors.white, 16, 'center', 'middle');

                            // Draw example elements
                            viz.drawPoint(2, 1, viz.colors.blue, 'a ∈ A', 6);
                            viz.drawPoint(-1.5, 0.5, viz.colors.orange, 'i ∈ I', 6);

                            // Show multiplication results
                            if (idealType === 'two-sided' || idealType === 'left') {
                                // ai ∈ I
                                viz.drawSegment(2, 1, -0.8, -0.5, viz.colors.green, 2, false);
                                viz.drawPoint(-0.8, -0.5, viz.colors.green, 'ai', 6);
                                viz.drawText('ai ∈ I', 1, -2, viz.colors.green, 14, 'center', 'middle');
                            }

                            if (idealType === 'two-sided' || idealType === 'right') {
                                // ia ∈ I (different location)
                                viz.drawSegment(-1.5, 0.5, -1.2, -0.8, viz.colors.teal, 2, false);
                                viz.drawPoint(-1.2, -0.8, viz.colors.teal, 'ia', 6);
                                viz.drawText('ia ∈ I', -1, -2.5, viz.colors.teal, 14, 'center', 'middle');
                            }

                            if (idealType === 'left') {
                                // ia might escape I
                                viz.drawSegment(-1.5, 0.5, 1.5, -1.5, viz.colors.red + '88', 2, true);
                                viz.drawPoint(1.5, -1.5, viz.colors.red, 'ia ∉ I?', 6);
                            }

                            if (idealType === 'right') {
                                // ai might escape I
                                viz.drawSegment(2, 1, 2, -1.8, viz.colors.red + '88', 2, true);
                                viz.drawPoint(2, -1.8, viz.colors.red, 'ai ∉ I?', 6);
                            }

                            let desc = '';
                            if (idealType === 'two-sided') {
                                desc = '<span style="color: ' + viz.colors.green + '">Two-sided ideal:</span> Both AI ⊆ I and IA ⊆ I.<br>' +
                                       'Products with I stay in I from both sides.<br>' +
                                       'This allows us to form quotient algebra A/I.';
                            } else if (idealType === 'left') {
                                desc = '<span style="color: ' + viz.colors.orange + '">Left ideal only:</span> AI ⊆ I.<br>' +
                                       'Products a·i stay in I, but i·a may escape.<br>' +
                                       'Not sufficient for quotient algebra.';
                            } else {
                                desc = '<span style="color: ' + viz.colors.orange + '">Right ideal only:</span> IA ⊆ I.<br>' +
                                       'Products i·a stay in I, but a·i may escape.<br>' +
                                       'Not sufficient for quotient algebra.';
                            }

                            infoDiv.innerHTML = desc;
                        }

                        draw();
                        return viz;
                    }
                }
            ],
            exercises: [
                {
                    question: 'Show that the kernel of any algebra homomorphism \\(\\phi : A \\to B\\) is a two-sided ideal of \\(A\\).',
                    hint: 'Use that \\(\\phi(ab) = \\phi(a)\\phi(b)\\) and \\(\\phi(i) = 0\\) for \\(i \\in \\ker \\phi\\).',
                    solution: 'Let \\(I = \\ker \\phi\\). For \\(a \\in A\\) and \\(i \\in I\\), we have \\(\\phi(ai) = \\phi(a)\\phi(i) = \\phi(a) \\cdot 0 = 0\\), so \\(ai \\in I\\). Similarly, \\(\\phi(ia) = \\phi(i)\\phi(a) = 0 \\cdot \\phi(a) = 0\\), so \\(ia \\in I\\). Thus \\(I\\) is a two-sided ideal.'
                },
                {
                    question: 'Prove that in a commutative algebra, every left ideal is automatically a right ideal (and vice versa).',
                    hint: 'If \\(ab = ba\\) for all \\(a, b\\), what does this say about \\(AI\\) versus \\(IA\\)?',
                    solution: 'If \\(A\\) is commutative and \\(I\\) is a left ideal, then for any \\(a \\in A\\) and \\(i \\in I\\), we have \\(ia = ai \\in I\\) (since \\(I\\) is a left ideal and \\(ai = ia\\)). Thus \\(IA \\subseteq I\\), so \\(I\\) is also a right ideal.'
                },
                {
                    question: 'Let \\(A = M_2(\\mathbb{R})\\) and let \\(I\\) be the set of matrices with zero second column. Show that \\(I\\) is a left ideal but not a right ideal.',
                    hint: 'Check that \\(AI \\subseteq I\\) but find a specific \\(i \\in I\\) and \\(a \\in A\\) with \\(ia \\notin I\\).',
                    solution: 'Matrices in \\(I\\) have the form \\(\\begin{pmatrix} a & 0 \\\\ b & 0 \\end{pmatrix}\\). For any \\(A \\in M_2(\\mathbb{R})\\), the product \\(A \\cdot \\begin{pmatrix} a & 0 \\\\ b & 0 \\end{pmatrix}\\) still has zero second column, so \\(AI \\subseteq I\\). However, \\(\\begin{pmatrix} 1 & 0 \\\\ 0 & 0 \\end{pmatrix} \\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix} \\notin I\\), so \\(I\\) is not a right ideal.'
                }
            ]
        },
        {
            id: 'ch18-sec03',
            title: 'Algebra Homomorphisms',
            content: `
                <h2>Algebra Homomorphisms</h2>

                <p>Homomorphisms between algebras preserve both the vector space and multiplicative structures, providing the natural notion of "structure-preserving map" in this category.</p>

                <div class="env-block definition">
                    <div class="env-title">Definition 18.6 (Algebra Homomorphism)</div>
                    <div class="env-body">
                        <p>Let \\(A\\) and \\(B\\) be algebras over the same field \\(F\\). A <strong>homomorphism</strong> (or \\(F\\)-algebra homomorphism) is a linear map \\(\\phi : A \\to B\\) that preserves multiplication:
                        \\[\\phi(ab) = \\phi(a)\\phi(b) \\quad \\text{for all } a, b \\in A\\]
                        If \\(A\\) and \\(B\\) are unital, we typically require \\(\\phi(1_A) = 1_B\\).</p>

                        <p>An <strong>isomorphism</strong> is a bijective homomorphism. We write \\(A \\cong B\\) if \\(A\\) and \\(B\\) are isomorphic.</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 18.4 (First Isomorphism Theorem for Algebras)</div>
                    <div class="env-body">
                        <p>Let \\(\\phi : A \\to B\\) be an algebra homomorphism. Then:
                        <ol>
                            <li>\\(\\ker \\phi\\) is a two-sided ideal of \\(A\\)</li>
                            <li>\\(\\text{im} \\, \\phi\\) is a subalgebra of \\(B\\)</li>
                            <li>There is an algebra isomorphism
                            \\[A / \\ker \\phi \\cong \\text{im} \\, \\phi\\]
                            given by \\(a + \\ker \\phi \\mapsto \\phi(a)\\).</li>
                        </ol>
                        </p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof</div>
                    <div class="env-body">
                        <p>(1) We showed \\(\\ker \\phi\\) is a two-sided ideal in Exercise 18.2.1.</p>

                        <p>(2) Since \\(\\phi\\) is linear, \\(\\text{im} \\, \\phi\\) is a subspace. For closure under multiplication: if \\(b_1 = \\phi(a_1)\\) and \\(b_2 = \\phi(a_2)\\), then \\(b_1 b_2 = \\phi(a_1)\\phi(a_2) = \\phi(a_1 a_2) \\in \\text{im} \\, \\phi\\).</p>

                        <p>(3) Define \\(\\bar{\\phi} : A/\\ker \\phi \\to \\text{im} \\, \\phi\\) by \\(\\bar{\\phi}(a + \\ker \\phi) = \\phi(a)\\). This is well-defined since \\(a + \\ker \\phi = a' + \\ker \\phi\\) iff \\(a - a' \\in \\ker \\phi\\) iff \\(\\phi(a) = \\phi(a')\\). The map \\(\\bar{\\phi}\\) is surjective by definition of image, and injective since \\(\\bar{\\phi}(a + \\ker \\phi) = 0\\) iff \\(\\phi(a) = 0\\) iff \\(a \\in \\ker \\phi\\) iff \\(a + \\ker \\phi = \\ker \\phi\\) (the zero of \\(A/\\ker \\phi\\)). Finally,
                        \\[\\bar{\\phi}((a + \\ker \\phi)(b + \\ker \\phi)) = \\bar{\\phi}(ab + \\ker \\phi) = \\phi(ab) = \\phi(a)\\phi(b) = \\bar{\\phi}(a + \\ker \\phi)\\bar{\\phi}(b + \\ker \\phi)\\]
                        so \\(\\bar{\\phi}\\) is an algebra homomorphism, hence an isomorphism.</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 18.5 (Evaluation Homomorphism)</div>
                    <div class="env-body">
                        <p>For any algebra \\(A\\) and element \\(a \\in A\\), the <strong>evaluation map</strong> \\(\\text{ev}_a : F[x] \\to A\\) defined by
                        \\[\\text{ev}_a(p(x)) = p(a)\\]
                        is an algebra homomorphism. Its image is the subalgebra \\(F[a]\\) generated by \\(a\\).</p>

                        <p>If \\(a\\) is algebraic over \\(F\\) with minimal polynomial \\(m(x)\\), then \\(\\ker(\\text{ev}_a) = \\langle m(x) \\rangle\\), giving
                        \\[F[a] \\cong F[x] / \\langle m(x) \\rangle\\]
                        </p>
                    </div>
                </div>

                <div class="env-block definition">
                    <div class="env-title">Definition 18.7 (Left Regular Representation)</div>
                    <div class="env-body">
                        <p>For any algebra \\(A\\), the <strong>left regular representation</strong> is the algebra homomorphism
                        \\[L : A \\to \\text{End}_F(A)\\]
                        defined by \\(L(a)(b) = ab\\) for \\(a, b \\in A\\). Here \\(\\text{End}_F(A)\\) denotes the algebra of linear operators on \\(A\\) (with operator composition as multiplication).</p>

                        <p>The map \\(L\\) is injective if and only if \\(A\\) has no nonzero <strong>left annihilator</strong>, i.e., no element \\(a \\neq 0\\) with \\(aA = \\{0\\}\\).</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 18.5 (Faithful Representation)</div>
                    <div class="env-body">
                        <p>If \\(A\\) is finite-dimensional and has no zero divisors (i.e., \\(ab = 0\\) implies \\(a = 0\\) or \\(b = 0\\)), then the left regular representation \\(L : A \\to \\text{End}_F(A)\\) is injective, hence \\(A\\) is isomorphic to a subalgebra of \\(M_n(F)\\) where \\(n = \\dim_F A\\).</p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof</div>
                    <div class="env-body">
                        <p>If \\(L(a) = 0\\), then \\(ab = 0\\) for all \\(b \\in A\\). Taking \\(b = 1\\) gives \\(a = 0\\). Thus \\(\\ker L = \\{0\\}\\) and \\(L\\) is injective.</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="env-block remark">
                    <div class="env-title">Remark</div>
                    <div class="env-body">
                        <p>The left regular representation realizes abstract algebras as concrete matrix algebras. This is especially powerful for division algebras, as we'll see in the next section.</p>
                    </div>
                </div>
            `,
            visualizations: [],
            exercises: [
                {
                    question: 'Prove that the composition of two algebra homomorphisms is an algebra homomorphism.',
                    hint: 'If \\(\\phi : A \\to B\\) and \\(\\psi : B \\to C\\) are homomorphisms, verify that \\(\\psi \\circ \\phi\\) preserves both addition and multiplication.',
                    solution: 'Let \\(\\phi : A \\to B\\) and \\(\\psi : B \\to C\\) be algebra homomorphisms. Then for \\(a_1, a_2 \\in A\\): (1) \\((\\psi \\circ \\phi)(a_1 + a_2) = \\psi(\\phi(a_1 + a_2)) = \\psi(\\phi(a_1) + \\phi(a_2)) = \\psi(\\phi(a_1)) + \\psi(\\phi(a_2)) = (\\psi \\circ \\phi)(a_1) + (\\psi \\circ \\phi)(a_2)\\). (2) \\((\\psi \\circ \\phi)(a_1 a_2) = \\psi(\\phi(a_1 a_2)) = \\psi(\\phi(a_1)\\phi(a_2)) = \\psi(\\phi(a_1))\\psi(\\phi(a_2)) = (\\psi \\circ \\phi)(a_1)(\\psi \\circ \\phi)(a_2)\\). Thus \\(\\psi \\circ \\phi\\) is an algebra homomorphism.'
                },
                {
                    question: 'Let \\(A\\) be an algebra and \\(a \\in A\\) be algebraic over \\(F\\) with minimal polynomial \\(m(x)\\) of degree \\(d\\). Show that \\(\\dim_F F[a] = d\\) and find a basis for \\(F[a]\\).',
                    hint: 'Use the isomorphism \\(F[a] \\cong F[x]/\\langle m(x) \\rangle\\) and recall that polynomials mod \\(m(x)\\) have degree less than \\(d\\).',
                    solution: 'By the first isomorphism theorem, \\(F[a] \\cong F[x]/\\langle m(x) \\rangle\\). In the quotient, every polynomial is equivalent to its remainder mod \\(m(x)\\), which has degree less than \\(d = \\deg m\\). Thus \\(\\{1 + \\langle m \\rangle, x + \\langle m \\rangle, \\ldots, x^{d-1} + \\langle m \\rangle\\}\\) is a basis for \\(F[x]/\\langle m \\rangle\\), implying \\(\\{1, a, a^2, \\ldots, a^{d-1}\\}\\) is a basis for \\(F[a]\\) and \\(\\dim_F F[a] = d\\).'
                },
                {
                    question: 'Show that the left regular representation \\(L : A \\to \\text{End}_F(A)\\) is always an algebra homomorphism, even if \\(A\\) has zero divisors.',
                    hint: 'Verify \\(L(ab) = L(a) \\circ L(b)\\) by checking their action on arbitrary \\(c \\in A\\).',
                    solution: 'For \\(a, b, c \\in A\\), we have \\(L(ab)(c) = (ab)c = a(bc) = L(a)(bc) = L(a)(L(b)(c)) = (L(a) \\circ L(b))(c)\\). Since this holds for all \\(c\\), \\(L(ab) = L(a) \\circ L(b)\\). Linearity of \\(L\\) follows from distributivity: \\(L(a + \\alpha b)(c) = (a + \\alpha b)c = ac + \\alpha(bc) = L(a)(c) + \\alpha L(b)(c)\\).'
                }
            ]
        },
        {
            id: 'ch18-sec04',
            title: 'Division Algebras',
            content: `
                <h2>Division Algebras</h2>

                <p>Division algebras are algebras where every nonzero element has a multiplicative inverse. They generalize fields by allowing non-commutative multiplication, leading to fascinating structures like the quaternions.</p>

                <div class="env-block definition">
                    <div class="env-title">Definition 18.8 (Division Algebra)</div>
                    <div class="env-body">
                        <p>A <strong>division algebra</strong> is a nonzero unital algebra \\(D\\) over a field \\(F\\) in which every nonzero element has a multiplicative inverse. Equivalently, for all \\(a \\in D\\) with \\(a \\neq 0\\), the left multiplication map \\(L_a : D \\to D\\) given by \\(L_a(x) = ax\\) is bijective.</p>

                        <p>A commutative division algebra is a <strong>field</strong> (containing \\(F\\) as a subfield).</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 18.6 (The Quaternions)</div>
                    <div class="env-body">
                        <p>The <strong>quaternions</strong> \\(\\mathbb{H}\\) form a 4-dimensional division algebra over \\(\\mathbb{R}\\) with basis \\(\\{1, i, j, k\\}\\) and multiplication rules:
                        \\[i^2 = j^2 = k^2 = -1, \\quad ijk = -1\\]
                        From these, we derive:
                        \\[ij = k, \\quad jk = i, \\quad ki = j, \\quad ji = -k, \\quad kj = -i, \\quad ik = -j\\]
                        </p>

                        <p>A general quaternion has the form \\(q = a + bi + cj + dk\\) with \\(a, b, c, d \\in \\mathbb{R}\\). The <strong>conjugate</strong> is \\(\\bar{q} = a - bi - cj - dk\\), and the <strong>norm</strong> is
                        \\[N(q) = q\\bar{q} = \\bar{q}q = a^2 + b^2 + c^2 + d^2\\]
                        For \\(q \\neq 0\\), the inverse is \\(q^{-1} = \\bar{q}/N(q)\\), making \\(\\mathbb{H}\\) a division algebra.</p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="quaternion-viz"></div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 18.6 (Finite-Dimensional Division Algebras are Simple)</div>
                    <div class="env-body">
                        <p>Every finite-dimensional division algebra \\(D\\) over a field \\(F\\) is simple.</p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof</div>
                    <div class="env-body">
                        <p>Let \\(I \\triangleleft D\\) be a nonzero two-sided ideal. Pick \\(0 \\neq a \\in I\\). Since \\(D\\) is a division algebra, \\(a^{-1}\\) exists. Then \\(1 = a^{-1} a \\in I\\) (since \\(I\\) is a left ideal). For any \\(d \\in D\\), we have \\(d = d \\cdot 1 \\in I\\), so \\(I = D\\).</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 18.7 (Division Algebras over Algebraically Closed Fields)</div>
                    <div class="env-body">
                        <p>If \\(F\\) is an algebraically closed field and \\(D\\) is a finite-dimensional division algebra over \\(F\\), then \\(D = F\\).</p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof</div>
                    <div class="env-body">
                        <p>Let \\(a \\in D\\). Since \\(D\\) is finite-dimensional, \\(a\\) is algebraic over \\(F\\), so it has a minimal polynomial \\(m(x) \\in F[x]\\). Since \\(F\\) is algebraically closed, \\(m(x)\\) splits completely. But a division algebra has no zero divisors, so \\(m(x)\\) must be irreducible. An irreducible polynomial over an algebraically closed field must be linear, so \\(m(x) = x - \\alpha\\) for some \\(\\alpha \\in F\\). Thus \\(a = \\alpha \\in F\\), proving \\(D = F\\).</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 18.8 (Wedderburn's Theorem)</div>
                    <div class="env-body">
                        <p>Every finite division algebra is a field (i.e., is commutative).</p>
                    </div>
                </div>

                <div class="env-block intuition">
                    <div class="env-title">Intuition</div>
                    <div class="env-body">
                        <p>Wedderburn's theorem is remarkable: it says that finite non-commutative division algebras don't exist! The proof uses the class equation from group theory combined with properties of cyclotomic polynomials. Over infinite fields like \\(\\mathbb{R}\\), non-commutative division algebras like \\(\\mathbb{H}\\) can exist.</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 18.9 (Frobenius Theorem, 1877)</div>
                    <div class="env-body">
                        <p>The only finite-dimensional division algebras over \\(\\mathbb{R}\\) are:
                        <ul>
                            <li>\\(\\mathbb{R}\\) itself (dimension 1)</li>
                            <li>\\(\\mathbb{C}\\) (dimension 2)</li>
                            <li>\\(\\mathbb{H}\\) (dimension 4)</li>
                        </ul>
                        </p>
                    </div>
                </div>

                <div class="env-block remark">
                    <div class="env-title">Remark (Hurwitz's Theorem)</div>
                    <div class="env-body">
                        <p>A related result of Hurwitz (1898) shows that the only <strong>normed division algebras</strong> over \\(\\mathbb{R}\\) are \\(\\mathbb{R}, \\mathbb{C}, \\mathbb{H}\\), and the <strong>octonions</strong> \\(\\mathbb{O}\\) (dimension 8). However, \\(\\mathbb{O}\\) is not associative, so it's not an associative algebra. The dimensions 1, 2, 4, 8 are the only possibilities for normed division algebras.</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'quaternion-viz',
                    title: 'Interactive: Quaternion Multiplication',
                    description: 'Visualize quaternion multiplication using the famous relations i² = j² = k² = -1 and ijk = -1. See how multiplication is non-commutative.',
                    setup: function(container, controls) {
                        const viz = new VizEngine(container, {width: 560, height: 450, scale: 1});

                        const basis = ['1', 'i', 'j', 'k'];
                        const multTable = [
                            [0, 1, 2, 3],    // 1·x = x
                            [1, -1, 3, -2],  // i·{1,i,j,k} = {i,-1,k,-j}  (note: -1 encoded as -1)
                            [2, -3, -1, 1],  // j·{1,i,j,k} = {j,-k,-1,i}
                            [3, 2, -1, -1]   // k·{1,i,j,k} = {k,j,-i,-1}
                        ];

                        const multTableSigns = [
                            [1, 1, 1, 1],
                            [1, -1, 1, -1],
                            [1, -1, -1, 1],
                            [1, 1, -1, -1]
                        ];

                        function formatProduct(i, j) {
                            const sign = multTableSigns[i][j];
                            const absVal = Math.abs(multTable[i][j]);
                            const result = basis[absVal];
                            return sign === 1 ? result : '-' + result;
                        }

                        let selectedI = 1, selectedJ = 2; // i, j

                        const infoDiv = document.createElement('div');
                        infoDiv.style.marginBottom = '15px';
                        infoDiv.style.fontFamily = 'monospace';
                        infoDiv.style.fontSize = '14px';
                        controls.appendChild(infoDiv);

                        const selectDiv1 = document.createElement('div');
                        selectDiv1.innerHTML = 'First factor: ';
                        selectDiv1.style.marginBottom = '8px';
                        const select1 = document.createElement('select');
                        select1.style.marginLeft = '10px';
                        select1.style.padding = '4px';
                        basis.forEach((b, i) => {
                            const opt = document.createElement('option');
                            opt.value = i;
                            opt.textContent = b;
                            select1.appendChild(opt);
                        });
                        select1.value = selectedI;
                        select1.addEventListener('change', (e) => {
                            selectedI = parseInt(e.target.value);
                            draw();
                        });
                        selectDiv1.appendChild(select1);
                        controls.appendChild(selectDiv1);

                        const selectDiv2 = document.createElement('div');
                        selectDiv2.innerHTML = 'Second factor: ';
                        const select2 = document.createElement('select');
                        select2.style.marginLeft = '10px';
                        select2.style.padding = '4px';
                        basis.forEach((b, i) => {
                            const opt = document.createElement('option');
                            opt.value = i;
                            opt.textContent = b;
                            select2.appendChild(opt);
                        });
                        select2.value = selectedJ;
                        select2.addEventListener('change', (e) => {
                            selectedJ = parseInt(e.target.value);
                            draw();
                        });
                        selectDiv2.appendChild(select2);
                        controls.appendChild(selectDiv2);

                        function draw() {
                            viz.clear();

                            const cellSize = 70;
                            const offsetX = 30;
                            const offsetY = 50;

                            viz.ctx.save();
                            viz.ctx.translate(offsetX, offsetY);

                            // Draw multiplication table
                            viz.ctx.font = 'bold 14px monospace';
                            viz.ctx.textAlign = 'center';
                            viz.ctx.textBaseline = 'middle';
                            viz.ctx.fillStyle = viz.colors.text;
                            viz.ctx.fillText('·', cellSize / 2, cellSize / 2);

                            // Headers
                            for (let i = 0; i < 4; i++) {
                                viz.ctx.fillText(basis[i], (i + 1) * cellSize + cellSize / 2, cellSize / 2);
                                viz.ctx.fillText(basis[i], cellSize / 2, (i + 1) * cellSize + cellSize / 2);
                            }

                            // Table entries
                            for (let i = 0; i < 4; i++) {
                                for (let j = 0; j < 4; j++) {
                                    const x = (j + 1) * cellSize;
                                    const y = (i + 1) * cellSize;

                                    // Highlight selected cell
                                    if (i === selectedI && j === selectedJ) {
                                        viz.ctx.fillStyle = viz.colors.blue + '44';
                                        viz.ctx.fillRect(x + 2, y + 2, cellSize - 4, cellSize - 4);
                                    }

                                    // Cell border
                                    viz.ctx.strokeStyle = viz.colors.text + '33';
                                    viz.ctx.strokeRect(x, y, cellSize, cellSize);

                                    // Product
                                    viz.ctx.fillStyle = viz.colors.white;
                                    viz.ctx.font = '12px monospace';
                                    viz.ctx.fillText(formatProduct(i, j), x + cellSize / 2, y + cellSize / 2);
                                }
                            }

                            viz.ctx.restore();

                            // Display selected multiplication
                            const product = formatProduct(selectedI, selectedJ);
                            const reverse = formatProduct(selectedJ, selectedI);
                            const isCommutative = product === reverse;

                            infoDiv.innerHTML = `<div style="font-size: 16px; margin-bottom: 8px;"><span style="color: ${viz.colors.blue}">${basis[selectedI]}</span> · <span style="color: ${viz.colors.orange}">${basis[selectedJ]}</span> = <span style="color: ${viz.colors.green}; font-weight: bold">${product}</span></div>` +
                                `<div style="font-size: 16px; margin-bottom: 8px;"><span style="color: ${viz.colors.orange}">${basis[selectedJ]}</span> · <span style="color: ${viz.colors.blue}">${basis[selectedI]}</span> = <span style="color: ${viz.colors.green}; font-weight: bold">${reverse}</span></div>` +
                                (isCommutative ?
                                    `<div style="color: ${viz.colors.green}">Commutative ✓</div>` :
                                    `<div style="color: ${viz.colors.red}">Non-commutative: ${basis[selectedI]}${basis[selectedJ]} ≠ ${basis[selectedJ]}${basis[selectedI]}</div>`);

                            // Draw fundamental relations
                            viz.ctx.fillStyle = viz.colors.text;
                            viz.ctx.font = '13px monospace';
                            viz.ctx.textAlign = 'left';
                            const relY = offsetY + 5 * cellSize + 30;
                            viz.ctx.fillText('Fundamental relations:', 20, relY);
                            viz.ctx.fillStyle = viz.colors.orange;
                            viz.ctx.fillText('i² = j² = k² = -1', 20, relY + 20);
                            viz.ctx.fillText('ijk = -1', 20, relY + 40);
                            viz.ctx.fillStyle = viz.colors.teal;
                            viz.ctx.fillText('ij = k,  jk = i,  ki = j', 240, relY + 20);
                            viz.ctx.fillText('ji = -k,  kj = -i,  ik = -j', 240, relY + 40);
                        }

                        draw();
                        return viz;
                    }
                }
            ],
            exercises: [
                {
                    question: 'Verify that the quaternion conjugation \\(q \\mapsto \\bar{q}\\) is an anti-homomorphism: \\(\\overline{pq} = \\bar{q}\\bar{p}\\) (note the order reversal).',
                    hint: 'Check this on the basis elements \\(\\{1, i, j, k\\}\\) first, then use linearity.',
                    solution: 'For basis elements: \\(\\overline{ij} = \\bar{k} = -k\\) and \\(\\bar{j}\\bar{i} = (-j)(-i) = ji = -k\\), confirming the relation. By bilinearity, this extends to all quaternions. The general proof: if \\(p = a + bi + cj + dk\\) and \\(q = a\' + b\'i + c\'j + d\'k\\), compute \\(pq\\) and then \\(\\overline{pq}\\), and separately compute \\(\\bar{q}\\bar{p}\\); they match by the multiplication rules.'
                },
                {
                    question: 'Show that the norm on quaternions is multiplicative: \\(N(pq) = N(p)N(q)\\).',
                    hint: 'Use that \\(N(q) = q\\bar{q}\\) and that conjugation is an anti-homomorphism.',
                    solution: '\\(N(pq) = (pq)\\overline{(pq)} = (pq)(\\bar{q}\\bar{p}) = p(q\\bar{q})\\bar{p} = p N(q) \\bar{p} = N(q) p\\bar{p} = N(q)N(p) = N(p)N(q)\\).'
                },
                {
                    question: 'Prove that \\(\\mathbb{C}\\) is a division algebra over \\(\\mathbb{R}\\) by explicitly constructing the inverse of a nonzero complex number.',
                    hint: 'For \\(z = a + bi \\neq 0\\), what is \\(z\\bar{z}\\)? Use this to construct \\(z^{-1}\\).',
                    solution: 'Let \\(z = a + bi\\) with \\(a, b \\in \\mathbb{R}\\) and \\(z \\neq 0\\). Then \\(z\\bar{z} = (a+bi)(a-bi) = a^2 + b^2 > 0\\). Define \\(z^{-1} = \\frac{\\bar{z}}{a^2+b^2} = \\frac{a-bi}{a^2+b^2}\\). Then \\(z \\cdot z^{-1} = \\frac{z\\bar{z}}{a^2+b^2} = \\frac{a^2+b^2}{a^2+b^2} = 1\\). Similarly \\(z^{-1} \\cdot z = 1\\).'
                }
            ]
        },
        {
            id: 'ch18-sec05',
            title: 'Matrix Algebras and the Tensor Product',
            content: `
                <h2>Matrix Algebras and the Tensor Product</h2>

                <p>Matrix algebras are fundamental building blocks in algebra theory. The tensor product provides a way to construct new algebras from existing ones, unifying many constructions in representation theory and algebraic geometry.</p>

                <div class="env-block definition">
                    <div class="env-title">Definition 18.9 (Matrix Algebra)</div>
                    <div class="env-body">
                        <p>For a field \\(F\\) and positive integer \\(n\\), the <strong>matrix algebra</strong> \\(M_n(F)\\) consists of all \\(n \\times n\\) matrices over \\(F\\), with:
                        <ul>
                            <li>Vector space structure: componentwise addition and scalar multiplication</li>
                            <li>Multiplication: standard matrix multiplication</li>
                            <li>Identity: \\(I_n\\) (the identity matrix)</li>
                            <li>Dimension: \\(\\dim_F M_n(F) = n^2\\)</li>
                        </ul>
                        </p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 18.10 (Structure of \\(M_n(F)\\))</div>
                    <div class="env-body">
                        <p>The matrix algebra \\(M_n(F)\\) is:
                        <ol>
                            <li><strong>Simple</strong>: Its only two-sided ideals are \\(\\{0\\}\\) and \\(M_n(F)\\)</li>
                            <li><strong>Central</strong>: \\(Z(M_n(F)) = F \\cdot I_n \\cong F\\) for \\(n \\geq 2\\)</li>
                            <li><strong>Not a division algebra</strong> for \\(n \\geq 2\\): It contains zero divisors</li>
                        </ol>
                        </p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="matrix-basis-viz"></div>

                <div class="env-block definition">
                    <div class="env-title">Definition 18.10 (Tensor Product of Algebras)</div>
                    <div class="env-body">
                        <p>Let \\(A\\) and \\(B\\) be algebras over a field \\(F\\). The <strong>tensor product algebra</strong> \\(A \\otimes_F B\\) is the tensor product of vector spaces with multiplication defined by:
                        \\[(a_1 \\otimes b_1)(a_2 \\otimes b_2) = (a_1 a_2) \\otimes (b_1 b_2)\\]
                        extended bilinearly to all of \\(A \\otimes B\\).</p>

                        <p>If \\(\\dim_F A = m\\) and \\(\\dim_F B = n\\), then \\(\\dim_F(A \\otimes_F B) = mn\\).</p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 18.7 (Tensor Product Examples)</div>
                    <div class="env-body">
                        <p><strong>(a) Complex Numbers</strong>: \\(\\mathbb{C} \\cong \\mathbb{R}[x]/\\langle x^2 + 1 \\rangle\\) can be viewed as \\(\\mathbb{R} \\otimes_{\\mathbb{R}} \\mathbb{C}\\) is \\(\\mathbb{C}\\) itself (as \\(\\mathbb{R}\\)-algebras).</p>

                        <p><strong>(b) Matrix Algebras</strong>: There is an isomorphism
                        \\[M_m(F) \\otimes_F M_n(F) \\cong M_{mn}(F)\\]
                        The map sends \\(A \\otimes B\\) to the block matrix with \\(A_{ij} B\\) in the \\((i,j)\\)-th block.</p>

                        <p><strong>(c) Base Extension</strong>: If \\(K/F\\) is a field extension and \\(A\\) is an \\(F\\)-algebra, then \\(K \\otimes_F A\\) is a \\(K\\)-algebra called the <strong>scalar extension</strong> of \\(A\\) to \\(K\\). For example, \\(\\mathbb{C} \\otimes_{\\mathbb{R}} M_n(\\mathbb{R}) \\cong M_n(\\mathbb{C})\\).</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 18.11 (Tensor Product of Matrix Algebras)</div>
                    <div class="env-body">
                        <p>For any field \\(F\\) and positive integers \\(m, n\\),
                        \\[M_m(F) \\otimes_F M_n(F) \\cong M_{mn}(F)\\]
                        as \\(F\\)-algebras.</p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof (Sketch)</div>
                    <div class="env-body">
                        <p>Let \\(\\{E_{ij}^{(m)}\\}\\) and \\(\\{E_{kl}^{(n)}\\}\\) be the elementary matrix bases for \\(M_m(F)\\) and \\(M_n(F)\\). Define \\(\\phi : M_m(F) \\otimes M_n(F) \\to M_{mn}(F)\\) by sending \\(E_{ij}^{(m)} \\otimes E_{kl}^{(n)}\\) to the \\(mn \\times mn\\) elementary matrix \\(E_{(i-1)n + k, (j-1)n + l}\\).</p>

                        <p>This map is bijective (dimension count: both sides have dimension \\(m^2 n^2\\)) and respects multiplication due to the relation \\(E_{ij} E_{kl} = \\delta_{jk} E_{il}\\) in both algebras.</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 18.12 (Universal Property of Tensor Product)</div>
                    <div class="env-body">
                        <p>Let \\(A, B, C\\) be \\(F\\)-algebras. A bilinear map \\(\\phi : A \\times B \\to C\\) (satisfying \\(\\phi(a_1 a_2, b) = \\phi(a_1, b)\\phi(a_2, b)\\) and \\(\\phi(a, b_1 b_2) = \\phi(a, b_1)\\phi(a, b_2)\\)) factors uniquely through \\(A \\otimes_F B\\):
                        \\[\\begin{array}{ccc}
                        A \\times B & \\xrightarrow{\\phi} & C \\\\
                        \\downarrow{\\otimes} & \\nearrow{\\exists ! \\bar{\\phi}} & \\\\
                        A \\otimes_F B & &
                        \\end{array}\\]
                        </p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 18.8 (Central Simple Algebras)</div>
                    <div class="env-body">
                        <p>An \\(F\\)-algebra \\(A\\) is <strong>central simple</strong> if it is simple and \\(Z(A) = F \\cdot 1\\). Examples include \\(M_n(F)\\) for \\(n \\geq 1\\) and division algebras \\(D\\) with \\(Z(D) = F\\).</p>

                        <p>The <strong>Artin-Wedderburn theorem</strong> states that every finite-dimensional central simple algebra over \\(F\\) is isomorphic to \\(M_n(D)\\) for some finite-dimensional division algebra \\(D\\) over \\(F\\) with \\(Z(D) = F\\). The integer \\(n\\) and the division algebra \\(D\\) are uniquely determined up to isomorphism.</p>
                    </div>
                </div>

                <div class="env-block remark">
                    <div class="env-title">Remark (Brauer Group)</div>
                    <div class="env-body">
                        <p>The tensor product allows us to define the <strong>Brauer group</strong> \\(\\text{Br}(F)\\), whose elements are equivalence classes of central simple algebras over \\(F\\). This group plays a crucial role in class field theory and algebraic number theory. For algebraically closed fields, \\(\\text{Br}(F) = 0\\).</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'matrix-basis-viz',
                    title: 'Interactive: Elementary Matrix Basis of M₂(F)',
                    description: 'Explore the elementary matrices E_ij that form a basis for the matrix algebra M₂(F). See how any 2×2 matrix is a linear combination of these.',
                    setup: function(container, controls) {
                        const viz = new VizEngine(container, {width: 560, height: 400, scale: 1});

                        const coeffs = [1, 0, 0, 1]; // coefficients for E11, E12, E21, E22

                        const sliders = [];
                        const labels = ['E₁₁', 'E₁₂', 'E₂₁', 'E₂₂'];

                        labels.forEach((label, i) => {
                            const slider = VizEngine.createSlider(controls, label, -3, 3, coeffs[i], 0.5, (val) => {
                                coeffs[i] = val;
                                draw();
                            });
                            sliders.push(slider);
                        });

                        const infoDiv = document.createElement('div');
                        infoDiv.style.marginTop = '15px';
                        infoDiv.style.fontFamily = 'monospace';
                        infoDiv.style.fontSize = '12px';
                        controls.appendChild(infoDiv);

                        function drawMatrix(ctx, x, y, size, m11, m12, m21, m22, label) {
                            // Draw bracket
                            ctx.strokeStyle = viz.colors.white;
                            ctx.lineWidth = 2;
                            const w = size;
                            const h = size * 1.2;

                            // Left bracket
                            ctx.beginPath();
                            ctx.moveTo(x - 5, y - h/2);
                            ctx.lineTo(x - 10, y - h/2);
                            ctx.lineTo(x - 10, y + h/2);
                            ctx.lineTo(x - 5, y + h/2);
                            ctx.stroke();

                            // Right bracket
                            ctx.beginPath();
                            ctx.moveTo(x + w + 5, y - h/2);
                            ctx.lineTo(x + w + 10, y - h/2);
                            ctx.lineTo(x + w + 10, y + h/2);
                            ctx.lineTo(x + w + 5, y + h/2);
                            ctx.stroke();

                            // Matrix entries
                            ctx.fillStyle = viz.colors.white;
                            ctx.font = '16px monospace';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';

                            const cellW = w / 2;
                            const cellH = h / 2;

                            ctx.fillText(m11.toFixed(1), x + cellW/2, y - cellH/2);
                            ctx.fillText(m12.toFixed(1), x + cellW + cellW/2, y - cellH/2);
                            ctx.fillText(m21.toFixed(1), x + cellW/2, y + cellH/2);
                            ctx.fillText(m22.toFixed(1), x + cellW + cellW/2, y + cellH/2);

                            // Label
                            if (label) {
                                ctx.fillStyle = viz.colors.text;
                                ctx.font = '14px monospace';
                                ctx.fillText(label, x + w/2, y + h/2 + 25);
                            }
                        }

                        function draw() {
                            viz.clear();

                            const y0 = 100;
                            const spacing = 100;

                            // Draw elementary matrices
                            viz.ctx.fillStyle = viz.colors.text;
                            viz.ctx.font = '14px monospace';
                            viz.ctx.textAlign = 'center';
                            viz.ctx.fillText('Basis: Elementary Matrices', 280, 30);

                            // E11
                            viz.ctx.fillStyle = viz.colors.blue;
                            viz.ctx.fillText(`${coeffs[0].toFixed(1)} ×`, 50, y0);
                            drawMatrix(viz.ctx, 80, y0, 60, 1, 0, 0, 0, 'E₁₁');

                            // E12
                            viz.ctx.fillStyle = viz.colors.orange;
                            viz.ctx.fillText(`${coeffs[1].toFixed(1)} ×`, 190, y0);
                            drawMatrix(viz.ctx, 220, y0, 60, 0, 1, 0, 0, 'E₁₂');

                            // E21
                            viz.ctx.fillStyle = viz.colors.green;
                            viz.ctx.fillText(`${coeffs[2].toFixed(1)} ×`, 330, y0);
                            drawMatrix(viz.ctx, 360, y0, 60, 0, 0, 1, 0, 'E₂₁');

                            // E22
                            viz.ctx.fillStyle = viz.colors.purple;
                            viz.ctx.fillText(`${coeffs[3].toFixed(1)} ×`, 470, y0);
                            drawMatrix(viz.ctx, 500, y0, 60, 0, 0, 0, 1, 'E₂₂');

                            // Equals sign
                            viz.ctx.fillStyle = viz.colors.white;
                            viz.ctx.font = '24px monospace';
                            viz.ctx.fillText('=', 280, 240);

                            // Result matrix
                            const m11 = coeffs[0];
                            const m12 = coeffs[1];
                            const m21 = coeffs[2];
                            const m22 = coeffs[3];

                            drawMatrix(viz.ctx, 230, 290, 100, m11, m12, m21, m22, 'Result');

                            // Info
                            const det = m11 * m22 - m12 * m21;
                            const trace = m11 + m22;

                            infoDiv.innerHTML = `<span style="color: ${viz.colors.teal}">Matrix Properties:</span><br>` +
                                `det = ${det.toFixed(2)}<br>` +
                                `trace = ${trace.toFixed(2)}<br>` +
                                `${det !== 0 ? '<span style="color: ' + viz.colors.green + '">Invertible ✓</span>' :
                                               '<span style="color: ' + viz.colors.red + '">Singular (det = 0)</span>'}<br><br>` +
                                `The 4 elementary matrices {E₁₁, E₁₂, E₂₁, E₂₂}<br>` +
                                `form a basis for M₂(F). Any 2×2 matrix is<br>` +
                                `a unique linear combination of these.`;
                        }

                        draw();
                        return viz;
                    }
                }
            ],
            exercises: [
                {
                    question: 'Show that the center of \\(M_2(F)\\) consists precisely of scalar matrices: \\(Z(M_2(F)) = \\{\\alpha I_2 : \\alpha \\in F\\}\\).',
                    hint: 'If \\(A\\) commutes with all matrices, it must commute with the elementary matrices \\(E_{ij}\\). Compute \\(AE_{12}\\) and \\(E_{12}A\\) for a general \\(A = \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}\\).',
                    solution: 'Let \\(A = \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix} \\in Z(M_2(F))\\). Then \\(AE_{12} = E_{12}A\\). Computing: \\(AE_{12} = \\begin{pmatrix} 0 & a \\\\ 0 & c \\end{pmatrix}\\) and \\(E_{12}A = \\begin{pmatrix} c & d \\\\ 0 & 0 \\end{pmatrix}\\). Equating gives \\(c = 0\\) and \\(a = d\\). Similarly, checking \\(AE_{21} = E_{21}A\\) gives \\(b = 0\\). Thus \\(A = aI_2\\).'
                },
                {
                    question: 'Prove that \\(\\dim_F(A \\otimes_F B) = (\\dim_F A)(\\dim_F B)\\) for finite-dimensional algebras \\(A\\) and \\(B\\).',
                    hint: 'Use that the tensor product of vector spaces has dimension equal to the product of dimensions.',
                    solution: "The tensor product \\(A \\otimes_F B\\) as a vector space is the tensor product of \\(A\\) and \\(B\\) as \\(F\\)-vector spaces. By the dimension formula for tensor products of vector spaces, \\(\\dim_F(A \\otimes_F B) = \\dim_F A \\cdot \\dim_F B\\). The algebra structure doesn't change the underlying vector space dimension."
                },
                {
                    question: 'Verify that the multiplication in \\(A \\otimes_F B\\) given by \\((a_1 \\otimes b_1)(a_2 \\otimes b_2) = (a_1a_2) \\otimes (b_1b_2)\\) is associative.',
                    hint: 'Check associativity on elementary tensors, then use bilinearity to extend.',
                    solution: 'For elementary tensors: \\([(a_1 \\otimes b_1)(a_2 \\otimes b_2)](a_3 \\otimes b_3) = [(a_1a_2) \\otimes (b_1b_2)](a_3 \\otimes b_3) = (a_1a_2a_3) \\otimes (b_1b_2b_3)\\). Similarly, \\((a_1 \\otimes b_1)[(a_2 \\otimes b_2)(a_3 \\otimes b_3)] = (a_1 \\otimes b_1)[(a_2a_3) \\otimes (b_2b_3)] = (a_1a_2a_3) \\otimes (b_1b_2b_3)\\). By associativity in \\(A\\) and \\(B\\), these are equal. Bilinearity extends this to all elements.'
                }
            ]
        },
        {
            id: 'ch18-sec06',
            title: 'The Structure Theory of Algebras',
            content: `
                <h2>The Structure Theory of Algebras</h2>

                <p>We conclude with the beautiful structure theorems that classify finite-dimensional algebras over special fields. These results, due to Frobenius, Wedderburn, and Artin, reveal the fundamental building blocks of algebra theory.</p>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 18.13 (Wedderburn's Structure Theorem)</div>
                    <div class="env-body">
                        <p>Every finite-dimensional semisimple algebra over a field \\(F\\) is isomorphic to a direct product of matrix algebras over division rings:
                        \\[A \\cong M_{n_1}(D_1) \\times M_{n_2}(D_2) \\times \\cdots \\times M_{n_k}(D_k)\\]
                        where each \\(D_i\\) is a division algebra over \\(F\\).</p>
                    </div>
                </div>

                <div class="env-block intuition">
                    <div class="env-title">Intuition</div>
                    <div class="env-body">
                        <p>This theorem says that semisimple algebras (algebras with no nonzero nilpotent ideals) are completely understood: they're just products of matrix algebras over division algebras. The hard part of understanding algebras is understanding division algebras themselves!</p>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 18.14 (Classification over \\(\\mathbb{C}\\))</div>
                    <div class="env-body">
                        <p>Every finite-dimensional central simple algebra over \\(\\mathbb{C}\\) is isomorphic to \\(M_n(\\mathbb{C})\\) for some \\(n \\geq 1\\).</p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof</div>
                    <div class="env-body">
                        <p>By the Artin-Wedderburn theorem, a central simple algebra over \\(\\mathbb{C}\\) has the form \\(M_n(D)\\) where \\(D\\) is a division algebra over \\(\\mathbb{C}\\) with \\(Z(D) = \\mathbb{C}\\). But Theorem 18.7 shows that the only finite-dimensional division algebra over \\(\\mathbb{C}\\) is \\(\\mathbb{C}\\) itself. Thus \\(A \\cong M_n(\\mathbb{C})\\).</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 18.15 (Classification over \\(\\mathbb{R}\\))</div>
                    <div class="env-body">
                        <p>Every finite-dimensional central simple algebra over \\(\\mathbb{R}\\) is isomorphic to one of:
                        <ul>
                            <li>\\(M_n(\\mathbb{R})\\) for some \\(n \\geq 1\\)</li>
                            <li>\\(M_n(\\mathbb{C})\\) for some \\(n \\geq 1\\)</li>
                            <li>\\(M_n(\\mathbb{H})\\) for some \\(n \\geq 1\\)</li>
                        </ul>
                        </p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof</div>
                    <div class="env-body">
                        <p>By Artin-Wedderburn, \\(A \\cong M_n(D)\\) where \\(D\\) is a division algebra over \\(\\mathbb{R}\\) with \\(Z(D) = \\mathbb{R}\\). By Frobenius's theorem (Theorem 18.9), \\(D\\) is one of \\(\\mathbb{R}, \\mathbb{C}, \\mathbb{H}\\), giving the stated classification.</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 18.9 (Clifford Algebras)</div>
                    <div class="env-body">
                        <p>The <strong>Clifford algebra</strong> \\(\\text{Cl}(n)\\) over \\(\\mathbb{R}\\) is generated by \\(e_1, \\ldots, e_n\\) with relations:
                        \\[e_i^2 = -1, \\quad e_i e_j = -e_j e_i \\text{ for } i \\neq j\\]
                        These algebras have dimension \\(2^n\\) and appear throughout physics and geometry.</p>

                        <p>For small \\(n\\):
                        <ul>
                            <li>\\(\\text{Cl}(0) \\cong \\mathbb{R}\\)</li>
                            <li>\\(\\text{Cl}(1) \\cong \\mathbb{C}\\) (with \\(e_1 = i\\))</li>
                            <li>\\(\\text{Cl}(2) \\cong \\mathbb{H}\\) (with \\(e_1 = i, e_2 = j\\))</li>
                            <li>\\(\\text{Cl}(3) \\cong \\mathbb{H} \\oplus \\mathbb{H}\\)</li>
                        </ul>
                        The pattern continues with <strong>Bott periodicity</strong>: \\(\\text{Cl}(n+8) \\cong \\text{Cl}(n) \\otimes M_{16}(\\mathbb{R})\\).
                        </p>
                    </div>
                </div>

                <div class="viz-placeholder" data-viz="classification-viz"></div>

                <div class="env-block theorem">
                    <div class="env-title">Theorem 18.16 (Brauer Group of \\(\\mathbb{R}\\))</div>
                    <div class="env-body">
                        <p>The Brauer group \\(\\text{Br}(\\mathbb{R}) \\cong \\mathbb{Z}/2\\mathbb{Z}\\), with representatives \\(\\mathbb{R}\\) and \\(\\mathbb{H}\\).</p>
                    </div>
                </div>

                <div class="env-block proof">
                    <div class="env-title">Proof (Sketch)</div>
                    <div class="env-body">
                        <p>Central simple algebras over \\(\\mathbb{R}\\) are \\(M_n(\\mathbb{R}), M_n(\\mathbb{C}), M_n(\\mathbb{H})\\). In the Brauer group, \\(M_n(D)\\) is equivalent to \\(D\\) (since tensoring with a matrix algebra doesn't change the Brauer class). We have \\(\\mathbb{C} \\otimes_{\\mathbb{R}} \\mathbb{C} \\cong \\mathbb{C} \\times \\mathbb{C}\\) (not simple), so \\([\\mathbb{C}]\\) has order dividing 2. Similarly, \\(\\mathbb{H} \\otimes_{\\mathbb{R}} \\mathbb{H} \\cong M_4(\\mathbb{R})\\), so \\([\\mathbb{H}]\\) has order dividing 2. Since \\(\\mathbb{C}\\) and \\(\\mathbb{H}\\) are non-isomorphic, \\(\\text{Br}(\\mathbb{R}) \\cong \\mathbb{Z}/2\\mathbb{Z}\\).</p>
                        <div class="qed">∎</div>
                    </div>
                </div>

                <div class="env-block remark">
                    <div class="env-title">Remark (Broader Context)</div>
                    <div class="env-body">
                        <p>The structure theory of algebras extends far beyond what we've covered:
                        <ul>
                            <li><strong>Local fields</strong>: Over \\(\\mathbb{Q}_p\\) (\\(p\\)-adic numbers), the Brauer group is \\(\\mathbb{Q}/\\mathbb{Z}\\)</li>
                            <li><strong>Global fields</strong>: Over \\(\\mathbb{Q}\\), the Brauer group is explicitly computable via class field theory</li>
                            <li><strong>Algebraic geometry</strong>: The Brauer group extends to schemes and plays a role in obstruction theory</li>
                            <li><strong>Hopf algebras</strong>: Algebras with a "comultiplication" structure, central to quantum groups</li>
                        </ul>
                        </p>
                    </div>
                </div>

                <div class="env-block example">
                    <div class="env-title">Example 18.10 (Applications)</div>
                    <div class="env-body">
                        <p><strong>Physics</strong>: Quaternions describe rotations in 3D space more efficiently than matrices. Clifford algebras are the mathematical foundation of spinors in quantum mechanics and general relativity.</p>

                        <p><strong>Coding Theory</strong>: Division algebras over finite fields (which must be commutative by Wedderburn) are finite fields, used in error-correcting codes.</p>

                        <p><strong>Representation Theory</strong>: The group algebra \\(\\mathbb{C}[G]\\) of a finite group \\(G\\) decomposes as a product of matrix algebras, each corresponding to an irreducible representation of \\(G\\).</p>
                    </div>
                </div>
            `,
            visualizations: [
                {
                    id: 'classification-viz',
                    title: 'Interactive: Classification Tree of Division Algebras',
                    description: 'Navigate the classification of finite-dimensional division algebras over different base fields.',
                    setup: function(container, controls) {
                        const viz = new VizEngine(container, {width: 560, height: 480, scale: 1});

                        const fields = ['ℂ (algebraically closed)', 'ℝ (real numbers)', 'ℚ (rationals)', 'Finite field'];
                        let selectedField = 0;

                        const fieldSelect = document.createElement('select');
                        fieldSelect.style.marginBottom = '15px';
                        fieldSelect.style.padding = '5px';
                        fieldSelect.style.fontSize = '14px';
                        fields.forEach((f, i) => {
                            const opt = document.createElement('option');
                            opt.value = i;
                            opt.textContent = f;
                            fieldSelect.appendChild(opt);
                        });
                        fieldSelect.addEventListener('change', (e) => {
                            selectedField = parseInt(e.target.value);
                            draw();
                        });
                        controls.appendChild(fieldSelect);

                        const infoDiv = document.createElement('div');
                        infoDiv.style.marginTop = '15px';
                        infoDiv.style.fontFamily = 'monospace';
                        infoDiv.style.fontSize = '12px';
                        controls.appendChild(infoDiv);

                        function drawBox(x, y, w, h, text, color) {
                            viz.ctx.fillStyle = color + '33';
                            viz.ctx.fillRect(x, y, w, h);
                            viz.ctx.strokeStyle = color;
                            viz.ctx.lineWidth = 2;
                            viz.ctx.strokeRect(x, y, w, h);

                            viz.ctx.fillStyle = viz.colors.white;
                            viz.ctx.font = '13px monospace';
                            viz.ctx.textAlign = 'center';
                            viz.ctx.textBaseline = 'middle';

                            const lines = text.split('\\n');
                            lines.forEach((line, i) => {
                                viz.ctx.fillText(line, x + w/2, y + h/2 + (i - (lines.length-1)/2) * 16);
                            });
                        }

                        function drawArrow(x1, y1, x2, y2, label) {
                            viz.ctx.strokeStyle = viz.colors.text;
                            viz.ctx.lineWidth = 1;
                            viz.ctx.beginPath();
                            viz.ctx.moveTo(x1, y1);
                            viz.ctx.lineTo(x2, y2);
                            viz.ctx.stroke();

                            // Arrowhead
                            const angle = Math.atan2(y2 - y1, x2 - x1);
                            viz.ctx.beginPath();
                            viz.ctx.moveTo(x2, y2);
                            viz.ctx.lineTo(x2 - 10*Math.cos(angle - Math.PI/6), y2 - 10*Math.sin(angle - Math.PI/6));
                            viz.ctx.moveTo(x2, y2);
                            viz.ctx.lineTo(x2 - 10*Math.cos(angle + Math.PI/6), y2 - 10*Math.sin(angle + Math.PI/6));
                            viz.ctx.stroke();

                            if (label) {
                                viz.ctx.fillStyle = viz.colors.text;
                                viz.ctx.font = '11px monospace';
                                viz.ctx.textAlign = 'center';
                                viz.ctx.fillText(label, (x1 + x2)/2, (y1 + y2)/2 - 8);
                            }
                        }

                        function draw() {
                            viz.clear();

                            // Title
                            viz.ctx.fillStyle = viz.colors.white;
                            viz.ctx.font = 'bold 16px monospace';
                            viz.ctx.textAlign = 'center';
                            viz.ctx.fillText('Finite-Dimensional Division Algebras', 280, 25);

                            const fieldName = fields[selectedField].split(' ')[0];
                            viz.ctx.font = '14px monospace';
                            viz.ctx.fillStyle = viz.colors.blue;
                            viz.ctx.fillText(`Base Field: ${fieldName}`, 280, 50);

                            if (selectedField === 0) {
                                // Algebraically closed
                                drawBox(210, 100, 140, 60, 'Only division\\nalgebra: F', viz.colors.green);

                                infoDiv.innerHTML = '<span style="color: ' + viz.colors.green + '">Theorem 18.7:</span><br>' +
                                    'Over an algebraically closed field F,<br>' +
                                    'the only finite-dimensional division algebra is F itself.<br><br>' +
                                    '<span style="color: ' + viz.colors.teal + '">Example:</span> Over ℂ, only ℂ is a division algebra.';

                            } else if (selectedField === 1) {
                                // Real numbers
                                drawBox(50, 100, 100, 50, 'ℝ\\ndim = 1', viz.colors.blue);
                                drawBox(230, 100, 100, 50, 'ℂ\\ndim = 2', viz.colors.orange);
                                drawBox(410, 100, 100, 50, 'ℍ\\ndim = 4', viz.colors.purple);

                                drawBox(180, 200, 200, 80, 'Frobenius Theorem (1877)\\nThese are the ONLY\\nfinite-dimensional\\ndivision algebras over ℝ', viz.colors.green);

                                infoDiv.innerHTML = '<span style="color: ' + viz.colors.green + '">Frobenius Theorem:</span><br>' +
                                    'The only finite-dimensional division algebras<br>' +
                                    'over ℝ are ℝ, ℂ, and ℍ (quaternions).<br><br>' +
                                    'Dimensions: 1, 2, 4 (note: no dimension 3!)<br>' +
                                    'ℝ and ℂ are commutative (fields).<br>' +
                                    'ℍ is non-commutative.';

                            } else if (selectedField === 2) {
                                // Rationals
                                drawBox(130, 100, 120, 50, 'ℚ\\ndim = 1', viz.colors.blue);
                                drawBox(310, 100, 120, 50, 'Finite extensions\\nof ℚ (fields)', viz.colors.orange);

                                drawBox(130, 200, 120, 60, 'ℚ(√2)\\nℚ(√-1) = ℚ(i)\\nℚ(ζₙ)', viz.colors.teal);

                                drawBox(310, 200, 120, 60, 'Quaternion\\nalgebras over ℚ\\n(non-comm.)', viz.colors.purple);

                                drawArrow(190, 150, 190, 195, 'examples');
                                drawArrow(370, 150, 370, 195, 'examples');

                                drawBox(150, 310, 260, 70, 'Infinitely many non-isomorphic\\ndivision algebras!\\nClassified by class field theory', viz.colors.green);

                                infoDiv.innerHTML = '<span style="color: ' + viz.colors.orange + '">Over ℚ:</span><br>' +
                                    'Many division algebras exist, both<br>' +
                                    'commutative (field extensions like ℚ(√2))<br>' +
                                    'and non-commutative (quaternion algebras).<br><br>' +
                                    'Classification involves deep number theory<br>' +
                                    'and the Brauer group Br(ℚ).';

                            } else {
                                // Finite field
                                drawBox(180, 100, 200, 80, "Wedderburn's Theorem\\n\\nEvery finite division\\nalgebra is a field\\n(i.e., commutative)", viz.colors.green);

                                drawBox(150, 230, 260, 80, 'Over 𝔽_q (field with q elements):\\n\\nAll finite-dimensional division algebras\\nare finite field extensions 𝔽_{q^n}', viz.colors.blue);

                                infoDiv.innerHTML = '<span style="color: ' + viz.colors.green + '">Wedderburn\'s Theorem:</span><br>' +
                                    'Every finite division algebra is commutative,<br>' +
                                    'hence a field.<br><br>' +
                                    'Over 𝔽_q: Division algebras are exactly<br>' +
                                    'the finite field extensions 𝔽_{q^n}.<br><br>' +
                                    'No non-commutative finite division algebras exist!';
                            }
                        }

                        draw();
                        return viz;
                    }
                }
            ],
            exercises: [
                {
                    question: 'Show that \\(\\mathbb{C} \\otimes_{\\mathbb{R}} \\mathbb{C} \\cong \\mathbb{C} \\times \\mathbb{C}\\) as \\(\\mathbb{R}\\)-algebras. (Hint: Find the idempotents in \\(\\mathbb{C} \\otimes \\mathbb{C}\\).)',
                    hint: 'Consider the elements \\(e_1 = \\frac{1}{2}(1 \\otimes 1 + i \\otimes i)\\) and \\(e_2 = \\frac{1}{2}(1 \\otimes 1 - i \\otimes i)\\). Show they are orthogonal idempotents.',
                    solution: 'Define \\(e_1 = \\frac{1}{2}(1 \\otimes 1 + i \\otimes i)\\) and \\(e_2 = \\frac{1}{2}(1 \\otimes 1 - i \\otimes i)\\). Then \\(e_1^2 = \\frac{1}{4}[(1\\otimes 1)^2 + 2(i \\otimes i) + (i \\otimes i)^2] = \\frac{1}{4}[1 \\otimes 1 + 2i \\otimes i - 1 \\otimes 1] = \\frac{1}{2}(1 \\otimes 1 + i \\otimes i) = e_1\\). Similarly \\(e_2^2 = e_2\\) and \\(e_1 e_2 = 0\\), \\(e_1 + e_2 = 1 \\otimes 1\\). Thus \\(\\mathbb{C} \\otimes \\mathbb{C} = e_1(\\mathbb{C} \\otimes \\mathbb{C}) \\oplus e_2(\\mathbb{C} \\otimes \\mathbb{C}) \\cong \\mathbb{C} \\times \\mathbb{C}\\).'
                },
                {
                    question: 'Prove that the Clifford algebra \\(\\text{Cl}(1)\\) generated by \\(e_1\\) with \\(e_1^2 = -1\\) is isomorphic to \\(\\mathbb{C}\\) as an \\(\\mathbb{R}\\)-algebra.',
                    hint: 'Show that the map \\(\\mathbb{R}[e_1] \\to \\mathbb{C}\\) sending \\(e_1 \\mapsto i\\) is an isomorphism.',
                    solution: 'Define \\(\\phi : \\text{Cl}(1) \\to \\mathbb{C}\\) by \\(\\phi(a + be_1) = a + bi\\). This is clearly \\(\\mathbb{R}\\)-linear and bijective (both have dimension 2). For multiplicativity: \\(\\phi((a + be_1)(c + de_1)) = \\phi(ac - bd + (ad + bc)e_1) = (ac - bd) + (ad + bc)i\\), and \\(\\phi(a + be_1)\\phi(c + de_1) = (a + bi)(c + di) = (ac - bd) + (ad + bc)i\\). Thus \\(\\phi\\) is an isomorphism.'
                },
                {
                    question: 'Use the classification of division algebras over \\(\\mathbb{R}\\) to show that every finite-dimensional central simple algebra over \\(\\mathbb{R}\\) has dimension \\(n^2, 2n^2,\\) or \\(4n^2\\) for some positive integer \\(n\\).',
                    hint: 'Apply Theorem 18.15: such algebras are \\(M_n(D)\\) where \\(D \\in \\{\\mathbb{R}, \\mathbb{C}, \\mathbb{H}\\}\\).',
                    solution: 'By Theorem 18.15, every finite-dimensional central simple algebra over \\(\\mathbb{R}\\) is isomorphic to \\(M_n(D)\\) where \\(D \\in \\{\\mathbb{R}, \\mathbb{C}, \\mathbb{H}\\}\\). We have \\(\\dim_{\\mathbb{R}} M_n(\\mathbb{R}) = n^2\\), \\(\\dim_{\\mathbb{R}} M_n(\\mathbb{C}) = n^2 \\cdot 2 = 2n^2\\), and \\(\\dim_{\\mathbb{R}} M_n(\\mathbb{H}) = n^2 \\cdot 4 = 4n^2\\). Thus the dimension is \\(n^2, 2n^2,\\) or \\(4n^2\\).'
                }
            ]
        }
    ]
});
